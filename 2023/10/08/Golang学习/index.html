<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Zhen Xie">





<title>Golang学习 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>
<script>
    !
    function() {
    function n(n, e, t) {
    return n.getAttribute(e) || t
    }
    function e(n) {
    return document.getElementsByTagName(n)
    }
    function t() {
    var t = e("script"),
    o = t.length,
    i = t[o - 1];
    return {
    l: o,
    z: n(i, "zIndex", -1), //置于主页面背后
    o: n(i, "opacity", .5), //线条透明度
    c: n(i, "color", "0,0,0"), //线条颜色
    n: n(i, "count", 100) //线条数量
    }
    }
    function o() {
    a = m.width = window.innerWidth ||
    document.documentElement.clientWidth || document.body.clientWidth,
    c = m.height = window.innerHeight ||
    document.documentElement.clientHeight || document.body.clientHeight
    }
    function i() {
    r.clearRect(0, 0, a, c);
    var n, e, t, o, m, l;
    s.forEach(function(i, x) {
    for (i.x += i.xa, i.y += i.ya, i.xa *= i.x > a || i.x < 0 ? -1 :
    1, i.ya *= i.y > c || i.y < 0 ? -1 : 1, r.fillRect(i.x - .5, i.y - .5, 1,
    1), e = x + 1; e < u.length; e++) n = u[e],
    null !== n.x && null !== n.y && (o = i.x - n.x, m = i.y - n.y, l
    = o * o + m * m, l < n.max && (n === y && l >= n.max / 2 && (i.x -= .03 * o,
    i.y -= .03 * m), t = (n.max - l) / n.max, r.beginPath(), r.lineWidth = t /
    2, r.strokeStyle = "rgba(" + d.c + "," + (t + .2) + ")", r.moveTo(i.x, i.y),
    r.lineTo(n.x, n.y), r.stroke()))
    }),
    x(i)
    }
    var a, c, u, m = document.createElement("canvas"),
    d = t(),
    l = "c_n" + d.l,
    r = m.getContext("2d"),
    x = window.requestAnimationFrame || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(n) {
    window.setTimeout(n, 1e3 / 45)
    },
    w = Math.random,
    y = {
    x: null,
    y: null,
    max: 2e4
    };
    m.id = l,
    m.style.cssText = "position:fixed;top:0;left:0;z-index:" + d.z +
    ";opacity:" + d.o,
    e("body")[0].appendChild(m),
    o(),
    window.onresize = o,
    window.onmousemove = function(n) {
    n = n || window.event,
    y.x = n.clientX,
    y.y = n.clientY
    },
    window.onmouseout = function() {
    y.x = null,
    y.y = null
    };
    for (var s = [], f = 0; d.n > f; f++) {
    var h = w() * a,
    g = w() * c,
    v = 2 * w() - 1,
    p = 2 * w() - 1;
    s.push({
    x: h,
    y: g,
    xa: v,
    ya: p,
    max: 6e3
    })
    }
    u = s.concat([y]),
    setTimeout(function() {
    i()
    },
    100)
    } ();
    </script>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">TheXie&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">TheXie&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Golang学习</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Zhen Xie</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">October 8, 2023&nbsp;&nbsp;22:24:21</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/language/">language</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Golang学习"><a href="#Golang学习" class="headerlink" title="Golang学习"></a>Golang学习</h1><h3 id="初学"><a href="#初学" class="headerlink" title="初学"></a>初学</h3><h5 id="Go程序开发注意："><a href="#Go程序开发注意：" class="headerlink" title="Go程序开发注意："></a>Go程序开发注意：</h5><p>1）go语言严格区分大小写</p>
<p>2）go每个语句不需要写分号（也可以加）</p>
<p>3）go编辑器是一行一行进行编译的，不能多行写在一行内，一行写一条语句</p>
<p>4）go语言定义的变量或者import的包如果没用到，则无法编译通过</p>
<h5 id="Go语言转移字符："><a href="#Go语言转移字符：" class="headerlink" title="Go语言转移字符："></a>Go语言转移字符：</h5><p>1）\t:制表符</p>
<ol start="2">
<li><p>\n：换行</p>
</li>
<li><p>\: \</p>
</li>
<li><p>\“:”</p>
</li>
<li><p>\r:回车，从当前行的最前面开始输出，覆盖以前的内容</p>
</li>
</ol>
<h5 id="排版："><a href="#排版：" class="headerlink" title="排版："></a>排版：</h5><p>1）gofmt -w xx.go（将格式化后的内容重新写入文件）</p>
<p>2）运算符两边都要用空格隔开</p>
<p>eg：num &#x3D; 2 + 1</p>
<p>3）right：</p>
<p>func main（）{</p>
<p>​           num &#x3D; 2 + 1</p>
<p>}</p>
<p>wrong：</p>
<p>func main（）</p>
<p>{</p>
<p>​           num &#x3D; 2 + 1</p>
<p>}</p>
<h5 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h5><h6 id="变量的声明："><a href="#变量的声明：" class="headerlink" title="变量的声明："></a>变量的声明：</h6><p>c中： int i；</p>
<p>golang中：var i int</p>
<h6 id="golang变量使用三种类型："><a href="#golang变量使用三种类型：" class="headerlink" title="golang变量使用三种类型："></a>golang变量使用三种类型：</h6><p>1）指定变量类型，声明后不赋值，使用默认值</p>
<p>var i int</p>
<p>2）根据值自行判定变量类型（类型推导）</p>
<p>var num &#x3D; 10.11</p>
<p>3）省略var，&#x3D;用：&#x3D;代替</p>
<p>name  :&#x3D; “tom”</p>
<h6 id="声明多个变量："><a href="#声明多个变量：" class="headerlink" title="声明多个变量："></a>声明多个变量：</h6><p>1）var n1，n2，n3 int</p>
<p>2）var n1，name，n3 &#x3D; 100，“tom”，888</p>
<p>3）n1,name,n3 :&#x3D; 100,”tom”,888</p>
<h6 id="（全局变量）一次性声明："><a href="#（全局变量）一次性声明：" class="headerlink" title="（全局变量）一次性声明："></a>（全局变量）一次性声明：</h6><p>var n1&#x3D;100</p>
<p>var n2&#x3D;200</p>
<p>var name&#x3D;”jack”</p>
<p>一次性声明：<br>var（</p>
<p>n3&#x3D;300</p>
<p>n4&#x3D;900</p>
<p>name2&#x3D;”many“</p>
<p>）</p>
<p>例如引入多个包也可以这样写：</p>
<p>import（</p>
<p>   ”fmt“</p>
<p>​    ”unsafe“</p>
<p>_”fmt”  &#x2F;&#x2F;如果没用到一个包，又想去掉，加个__表忽略</p>
<p>）</p>
<h6 id="如何查看某个变量的字节大小与数据类型："><a href="#如何查看某个变量的字节大小与数据类型：" class="headerlink" title="如何查看某个变量的字节大小与数据类型："></a>如何查看某个变量的字节大小与数据类型：</h6><p>fmt.Printf(“n1类型%T,n1占用字节数%d”,n1，unsafe.Sizeof(n1))</p>
<p>&#x2F;&#x2F;unsafe包中函数，可以返回变量占用字节数</p>
<h6 id="字符串变量注意事项："><a href="#字符串变量注意事项：" class="headerlink" title="字符串变量注意事项："></a>字符串变量注意事项：</h6><p>1）字符串一旦赋值则不能修改，go中字符串是不可变，即不能修改的。</p>
<p>eg：var str string &#x3D; ”hello world“</p>
<p>str[0]&#x3D;”y”&#x2F;&#x2F;报错，不能修改</p>
<p>2）字符串两种表示形式</p>
<p>1.双引号（常用），会识别转义符</p>
<p>2.反引号（&#96;&#96;）以字符串原生形式输出，包括换行与特殊字符</p>
<p>3）当一行字符串太长，需要多行字符串时：</p>
<p>eg：</p>
<p>right:</p>
<p>str：&#x3D;”hello“+</p>
<p>“world”</p>
<p>wrong:</p>
<p>str：&#x3D;”hello“</p>
<p>+”world”</p>
<h6 id="基本数据类型的转换："><a href="#基本数据类型的转换：" class="headerlink" title="基本数据类型的转换："></a>基本数据类型的转换：</h6><p>golang与java&#x2F;C不同，不同类型的变量之间赋值时需要显示转换，也就是说不能自动转换。</p>
<p>eg：var i int32 &#x3D; 100</p>
<p>var n1 float32 &#x3D; float32(i)</p>
<p>var n3 int64 &#x3D; int64(i)&#x2F;&#x2F;低转高也要显示转换</p>
<p>被转换的是变量存储的数据（即值），变量本身的数据类型没变。</p>
<p>高转低转换结果按溢出处理</p>
<h6 id="转string类型："><a href="#转string类型：" class="headerlink" title="转string类型："></a>转string类型：</h6><p>1)fmt.Sprintf()</p>
<p>var num1 int&#x3D;99</p>
<p>str&#x3D;fmt.Sprintf(“%d”,num1)</p>
<p>2)strconv函数</p>
<p>str&#x3D;strconv.FormatInt(int64(num3),10)</p>
<p>str&#x3D;strconv.FormatFloat(num4,’f’,10,64)</p>
<p>&#x2F;&#x2F;‘f’:表格式 10：小数位保留10位 64：小数是float64</p>
<p>str&#x3D;strconv.FormatBool(b2)</p>
<p>str&#x3D;strconv.Itoa(num5)&#x2F;&#x2F;整数int转字符</p>
<h6 id="string转基本数据类型："><a href="#string转基本数据类型：" class="headerlink" title="string转基本数据类型："></a>string转基本数据类型：</h6><p>b ,  _ &#x3D; strconv.ParseBool(str)&#x2F;&#x2F;函数会返回两个值（value bool，err error）</p>
<p>n1 , _ &#x3D; strconv.ParseInt(str,10,64)</p>
<p>n2 , _ &#x3D; strconv.ParseFloat(str,6 4)</p>
<h5 id="指针："><a href="#指针：" class="headerlink" title="指针："></a>指针：</h5><p>var ptr *int &#x3D; &amp;num</p>
<p>ptr ：指向的num的地址</p>
<p>&amp;ptr：ptr的地址</p>
<p>*ptr：指向的num的值</p>
<h5 id="golang类型"><a href="#golang类型" class="headerlink" title="golang类型"></a>golang类型</h5><p>值类型：变量直接存储值，内存通常在栈中分片</p>
<p>基本数据类型 int类型，float类型，bool，string，数组和结构体struct</p>
<p>引用类型：存储变量是一个地址，地址对应的空间才是真正存储数据值，内存通常在堆上分片，当没有任何变量引用这个地址是，对应的数据空间就成了垃圾，由GC回收</p>
<p>指针，slice切片，map，管道chan，interface</p>
<h6 id="标识符命名注意事项："><a href="#标识符命名注意事项：" class="headerlink" title="标识符命名注意事项："></a>标识符命名注意事项：</h6><p>1）变量名，函数名，常量名：采用驼峰法：形式：xxxxYyyyZzzzz</p>
<p>2）如果以上首字母大写，则可以被其他包访问：如果首字母小写，则只能在本包中使用（可以理解位首字母大写为公开的（public），小写是私有的（private））</p>
<h6 id="算术运算符使用事项"><a href="#算术运算符使用事项" class="headerlink" title="算术运算符使用事项:"></a>算术运算符使用事项:</h6><p>1）Golang中，++和–只能独立使用</p>
<p>eg：wrong： a&#x3D;i++    a&#x3D;i–</p>
<p>right：i++</p>
<p>a&#x3D;i</p>
<p>2）++和–只能写在变量后面，不能写在变量签名，只有a++，没有++a</p>
<p>3）go语言不支持三元运算符</p>
<h6 id="键盘输入函数："><a href="#键盘输入函数：" class="headerlink" title="键盘输入函数："></a>键盘输入函数：</h6><p>1）fmt.Scanln（）</p>
<p>eg：fmt.Scanln(&amp;name)</p>
<p>2)fmt.Scanf()(更类似于c语言)</p>
<p>eg:fmt.Scanf(“%s %d %f %t”,&amp;name,&amp;age,&amp;sal,&amp;isPass)</p>
<h5 id="程序流程："><a href="#程序流程：" class="headerlink" title="程序流程："></a>程序流程：</h5><h6 id="if使用细节："><a href="#if使用细节：" class="headerlink" title="if使用细节："></a>if使用细节：</h6><p>1）if条件中是不用括号括起来的</p>
<p>2）if条件判断语句中允许声明一个变量，这个变量的作用域只能在该条件逻辑块中，其他地方不起作用</p>
<p>eg：if age：&#x3D;20；age &gt; 18{</p>
<p>fmt.println(“xxxx”)</p>
<p>}</p>
<p>3）else放的位置：</p>
<p>if{</p>
<p>}else{</p>
<p>}</p>
<h6 id="switch使用细节："><a href="#switch使用细节：" class="headerlink" title="switch使用细节："></a>switch使用细节：</h6><p>1）匹配项后不需要再加break</p>
<p>2）case后的表达式可以有多个，用逗号隔开</p>
<p>3）case后是一个表达式（常量值，变量，一个有返回值的函数都可以）</p>
<p>4）switch后面也可以不带表达式，类似if-else语句</p>
<p>eg：switch{</p>
<p>   case age&#x3D;&#x3D;10：</p>
<p>​             xxxx</p>
<p>  case  age &#x3D;&#x3D; 20：</p>
<p>​             xxxx</p>
<p>}</p>
<p>5）switch后面也可以直接声明&#x2F;定义一个变量，分号结束，不推荐</p>
<p>eg：</p>
<p>switch grade :&#x3D; 90; {</p>
<p>case grade &gt; 90:</p>
<p>xxxx</p>
<p>case grade &gt;&#x3D;70 &amp;&amp; grade &lt;&#x3D;90:</p>
<p>xxxx</p>
<p>}</p>
<p>6)switch 穿透 fallthrought，如果在case语句块后增加fallthrough，则会继续执行下一个case</p>
<p>eg：</p>
<p>switch num{</p>
<p>​      case 10：</p>
<p>​               fmt.Println（“ok1”）</p>
<p>​                fallthrough&#x2F;&#x2F;默认只能穿透一层，如果num为10，则会输出ok1，ok2</p>
<p>​      case 20：</p>
<p>​               fmt.Println（“ok2”）</p>
<p>​     case 30：</p>
<p>​             fmt.Println（“ok3”）</p>
<p>}</p>
<p>7）Type Switch：switch语句还可以被用于type-switch来判断某个interface变量中实际指向的变量类型</p>
<h6 id="for的使用："><a href="#for的使用：" class="headerlink" title="for的使用："></a>for的使用：</h6><p>1）同样也不需要括号</p>
<p>2）for的多种写法</p>
<ol>
<li><p>for i:&#x3D;1;i&lt;&#x3D;10;i++{</p>
<p>}</p>
</li>
<li><p>j:&#x3D;1</p>
<p>for j&lt;&#x3D;10{</p>
<p>j++</p>
<p>}</p>
</li>
</ol>
<p>3.for{</p>
<p>}</p>
<p>这种写法等价for；；{}是个无限循环，通常搭配break使用</p>
<p>3）for-range字符串遍历方式</p>
<p>eg：for index，val:&#x3D;range str{</p>
<p>​      fmt.Printf(“index&#x3D;%d,val&#x3D;%c \n”,index,val)&#x2F;&#x2F;index指字符串下标，val指对应的值</p>
<p>}</p>
<p>4)如果字符串含有中文，则会出现乱码(for-range比较智能，能识别中文)，因为这是按字节遍历，而一个汉字对应3个字节。</p>
<p>how to solve：将str转为[]rune切片like this： str2:&#x3D;[]rune (str)</p>
<p>4）golang中没有while和do-while，但可以通过for循环来实现</p>
<h6 id="一些常用函数："><a href="#一些常用函数：" class="headerlink" title="一些常用函数："></a>一些常用函数：</h6><p>1）生成随机数：来自math&#x2F;rand</p>
<p>rand.Seed(time.Now().Unix())&#x2F;&#x2F;按秒数生成种子，可以改为rand.Seed(time.Now().UnixNano())</p>
<p>rand.Intn(100) &#x2F;&#x2F;生成[0 100)中的随机整数</p>
<p>2)swap的神奇用法：</p>
<p> 常用：temp：&#x3D;hs[i]</p>
<p>hs[i]&#x3D;hs[j]</p>
<p>hs[j]&#x3D;temp                                go中可以 hs[i],hs[j]&#x3D;hs[j],hs[i                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ]</p>
<h6 id="break，continue的使用："><a href="#break，continue的使用：" class="headerlink" title="break，continue的使用："></a>break，continue的使用：</h6><p>1）break，默认跳出最近的for循环，  在多层嵌套的语句块中，可以通过标签指明要终止的是哪一层语句块，标签的基本使用如下：（continue用法和break类似，只不过continue是用于结束本次循环，要执行下一次循环）</p>
<p>label1：{</p>
<p>label2:      {</p>
<p>label3:                       {            </p>
<p>​                                      break label2</p>
<p>​           }    </p>
<p>​    }</p>
<p>}</p>
<h5 id="引包："><a href="#引包：" class="headerlink" title="引包："></a>引包：</h5><h6 id="引包注意："><a href="#引包注意：" class="headerlink" title="引包注意："></a>引包注意：</h6><p>1）包名一般为小写字母，访问其函数，变量等名字首字母大写</p>
<p>2）在import包时，路径从$GOPATH的src开始，不用带src，编译器自动从src下开始引入</p>
<p>3）若包名太长可取别名如：（取别名后，原来包名不可用）</p>
<p>import（</p>
<p>  util  “go_code&#x2F;utils”</p>
<p>）</p>
<p>4）同一包下面不能有相同的函数</p>
<p>5)go.mod(常用引包方式)，在你的项目中你要先通过go mod init 名字（以g6为例）的方式生成go.mod文件，然后你想引用自定义的其他包时，只需要像这样import：“g6&#x2F;util&#x2F;math”(math为你想引那个包对应的文件名),就能直接引用，若想引用第三方包，则import：“github.com&#x2F;bytedance&#x2F;sonic” ,然后要么在终端输入go get github.com&#x2F;bytedance&#x2F;sonic，然后go.mod会出现require，并多出go.sum文件。要么直接在终端输入go mod tidy，自动根据你import中写的自动添加或删除，两种方法都行</p>
<h5 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h5><h6 id="函数注意事项："><a href="#函数注意事项：" class="headerlink" title="函数注意事项："></a>函数注意事项：</h6><p>1）基本数据类型和数组都是值传递，即进行值拷贝，若想改变函数外的变量，则传入变量的地址</p>
<p>2）Go函数不支持重载</p>
<p>3）函数也是一种数据类型，可以赋值给一个变量，则该变量就是一个函数类型的变量了。通过该变量可以对函数调用</p>
<p>eg：a：&#x3D;getSum</p>
<p>res:&#x3D;a(10,40)</p>
<p>4)函数可以作为形参，并且被调用</p>
<p>eg：myFun（funvar func（int，int） int，num1 int,num2 int ）{</p>
<p>   return funvar(num1,num2)</p>
<p>}</p>
<p>res2:&#x3D;myFun(getSum,50,60)</p>
<p>5)Go支持自定义数据类型</p>
<p>基本语法：type 自定义数据类型名 数据类型</p>
<p>eg type myInt int&#x2F;&#x2F;给int取别名，在go中myInt和int虽然都是int类型，但go认为这两个是不同的类型</p>
<p>6）支持对函数返回值命名</p>
<p>eg：func cal（n1 int，n2 int）（sum int，sub int）{</p>
<p>​       sum&#x3D;n1+n2</p>
<p>​      sub&#x3D;n1-n2</p>
<p>​     return</p>
<p>}</p>
<p>7）Go支持可变参数</p>
<p>eg：&#x2F;&#x2F;支持0到多个参数</p>
<p>func sum(args… int) sum int {</p>
<p>}</p>
<p>&#x2F;&#x2F;支持1到多个参数</p>
<p>func sum(n1 int,args… int) sum int{</p>
<p>}</p>
<p>&#x2F;&#x2F;args是slice切片，通过args[index]可以访问到各个值</p>
<h6 id="init函数："><a href="#init函数：" class="headerlink" title="init函数："></a>init函数：</h6><p>1）每个源文件都可以包含一个init函数，在main函数执行前被go运行框架调用</p>
<p>2）如果文件同时包含全局变量的定义，则执行流程是：变量定义——init函数——main函数</p>
<p>3）若main.go和utils.go都含变量定义，init函数时，执行流程如下</p>
<p> 1.utils.go变量定义</p>
<p>2.utils.go init函数</p>
<p>3.main.go 变量定义</p>
<p>4.main.go init函数</p>
<p>5.main.go main函数</p>
<h6 id="匿名函数："><a href="#匿名函数：" class="headerlink" title="匿名函数："></a>匿名函数：</h6><p>若只希望用一次，则可以使用匿名函数</p>
<p>1）定义匿名函数时直接调用，这种方式只能调用一次</p>
<p>eg： res1：&#x3D;func(n1 int,n2 int)int{</p>
<p>​       return n1+n2</p>
<p>}(10,20)</p>
<p>2）将匿名函数赋给一个变量（函数变量），在通过该变量调用匿名函数</p>
<p>a：&#x3D;func(n1 int,n2 int)int{</p>
<p>​       return n1+n2</p>
<p>}&#x2F;&#x2F;a的数据类型就是函数变量，此时可以通过a完成调用</p>
<p>3）全局匿名函数</p>
<p>将匿名函数赋给一个全局变量，则匿名函数成为一个全局匿名函数</p>
<p>eg：var（</p>
<p>​           Fun1&#x3D;func(n1 int,n2 int)int{</p>
<p>​       return n1+n2</p>
<p>}</p>
<p>）</p>
<h6 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h6><p>闭包是一个函数与其相关的引用环境组合的一个整体（实体）</p>
<p>eg： func AddUpper() func (int) int {</p>
<p>​        var n int &#x3D;10</p>
<p>​      return func (x int) int {</p>
<p>​          n&#x3D;n+x</p>
<p>​        return n </p>
<p>​     }</p>
<p>}</p>
<p>func main（）{</p>
<p>​        f：&#x3D;AddUpper（）</p>
<p>​          fmt.Println(f(1))&#x2F;&#x2F;11</p>
<p>​          fmt.Println(f(2))&#x2F;&#x2F;13</p>
<p>​          fmt.Println(f(3))&#x2F;&#x2F;16</p>
<p>}</p>
<p>&#x2F;&#x2F;1）AddUpper是一个函数，返回的数据类型是fun（int） int</p>
<p>2）返回的是个匿名函数，但是这个匿名函数引用到函数外的n，因此这个匿名函数和n形成一个整体，构成闭包，可以这样理解：闭包是类，函数是操作，n是字段。函数和它使用的n构成闭包，当我们反复调用f函数时，因为n是初始化一次，所以每次调用在累计  </p>
<h6 id="defer："><a href="#defer：" class="headerlink" title="defer："></a>defer：</h6><p>1）为了在函数执行完毕后，及时释放资源，使用defer（延时机制）</p>
<p>2）执行到defer时，暂时不执行，将其压入defer栈中，当函数执行完毕后，再从defer栈中按先入后出的方式出栈执行</p>
<p>eg：func sum….{</p>
<p>​          defer ….&#x2F;&#x2F;3  n1&#x3D;10</p>
<p>​           defer…..&#x2F;&#x2F;2  n2&#x3D;20 打印出来还是10与20</p>
<p>​          n1++  n2++ &#x2F;&#x2F;1   n1&#x3D;11,n2&#x3D;21</p>
<p>​                       </p>
<p>}</p>
<p>func main(){</p>
<p>​           ………&#x2F;&#x2F;4</p>
<p>}</p>
<p>3）主要价值：当函数执行完毕后，可以及时释放函数创建的资源：</p>
<p>func test（）{</p>
<p>​         file&#x3D;openfile()</p>
<p>​        defer file.close()</p>
<p>​        &#x2F;&#x2F;其他代码</p>
<p>}</p>
<h6 id="全局变量注意事项："><a href="#全局变量注意事项：" class="headerlink" title="全局变量注意事项："></a>全局变量注意事项：</h6><p>可以这样写：</p>
<p>var name &#x3D; “tom”</p>
<p>但不能这样写：</p>
<p>name ：&#x3D; “tom”&#x2F;&#x2F;这句话实质为两句话，先声明再赋值，全局变量不允许单独赋值，所以只能像上面一样边声明边赋值</p>
<h6 id="字符串常用系统函数："><a href="#字符串常用系统函数：" class="headerlink" title="字符串常用系统函数："></a>字符串常用系统函数：</h6><p>1）统计字符串长度，按字节len（str）</p>
<p>2）字符串遍历，同时处理有中文的问题 r:&#x3D;[]rune(str)</p>
<p>3)字符串转整数： n，err：&#x3D;strconv.Atoi(“12”)</p>
<p>4）整数转字符串 str&#x3D;strconv.Itoa(12345)</p>
<p>5)字符串转[]byte: var bytes&#x3D;[]byte(“hello”)</p>
<p>6)[]byte转字符串：str&#x3D;string（[]byte{97,98,99}）</p>
<p>7)10进制转2，8，16进制：str&#x3D;strconv.FormarInt(123,2),返回对应的字符串</p>
<p>8）查找子串是否再指定的字符串中：b:&#x3D;strings.Contains(“seafood”,”foo”)&#x2F;&#x2F;true返回为布尔类型，真或假</p>
<p>9）统计一个字符串有几个指定字串：num:&#x3D;strings.Count(“ceheese”,”e”)&#x2F;&#x2F;4</p>
<p>10)不区分大小写的字符串比较（&#x3D;&#x3D;区分字母大小写）：fmt.Println(strings.EqualFold(“abc”,”Abc”))&#x2F;&#x2F;返回为true</p>
<p>11）返回子串在字符串第一次出现的index值，如果没有返回-1：index：&#x3D;strings.Index(“NLT_abc”,”abc”)&#x2F;&#x2F;返回4</p>
<p>12）返回子串在字符串中最后一次出现的index，如果没有返回-1：index：&#x3D;strings.Index（”go golang“,”go”）&#x2F;&#x2F;返回3</p>
<p>13）将指定子串替换为另一子串：str：&#x3D;strings.Replace(“go go hello”,”go”,”北京”，1)&#x2F;&#x2F;北京 go hello(1表示换1个，如果为2则换两个，-1则全部换)</p>
<p>14）按指定某个字符，为分割标识，将一个字符串拆分为字符串数组：strArr：&#x3D;strings.Splot(“hello,world,ok”,”,”)&#x2F;&#x2F;拆分为字符串数组[hello world ok]</p>
<p>15）将字符串的字母进行大小写的转换：strings.ToLower(“Go”)&#x2F;&#x2F;go        strings.ToUpper(“Go”)&#x2F;&#x2F;GO</p>
<p>16)将字符串左右两边空格去掉：strings.TrimSpace(“  tn a lone  “)&#x2F;&#x2F;“tn a lone”</p>
<p>17)将字符串左右两边指定的字符去掉：strings.Trim(“! hello! “,” !”)&#x2F;&#x2F;“hello”左右两边！和 ” “都去掉</p>
<p>18）将左边的字符去掉：strings.TrimLeft(“! hello! “,” !”)</p>
<p>19）将右边的字符去掉：strings.TrimRight(“! hello! “,” !”)</p>
<p>20）判断字符串是否以指定的字符串开头：strings.HasPrefix(“ftp:&#x2F;&#x2F;….”,”ftp”)</p>
<p>21)判断字符串是否以指定的字符串结束：strings.HasSuffix(“….jpg”,”jpg”)</p>
<h6 id="时间函数："><a href="#时间函数：" class="headerlink" title="时间函数："></a>时间函数：</h6><p>1)time.Time类型表示时间</p>
<p>now：&#x3D;time.Now()</p>
<p>fmt.Printf(“now&#x3D;%v now type&#x3D;%T”,now,now)&#x2F;&#x2F;now type&#x3D;time.Time  </p>
<p>2)通过上面的now可以获取到年月日，时分秒</p>
<p>now.Year()</p>
<p>now.Month()&#x2F;&#x2F;英文，若转成数字则需要int(now.Month())</p>
<p>now.Day()</p>
<p>now.Hour()</p>
<p>now.Minute()</p>
<p>now,Second()</p>
<p>3)格式化日期时间：</p>
<p>fmt.Println(now.Format(“2006&#x2F;01&#x2F;02 15:04:05”))&#x2F;&#x2F;这里格式可以换，也可以只打印年月日或者时分秒，但是这些数据不能改</p>
<p>4）时间的常量</p>
<p>Nanosecond   纳秒</p>
<p>Microsecond  微秒</p>
<p>Millisecond  毫秒</p>
<p>Second 秒</p>
<p>Minute  分钟</p>
<p>Hour  小时</p>
<p>5）休眠</p>
<p>time.Sleep(time.Second)&#x2F;&#x2F;1秒</p>
<p>time.Sleep(time.Millisecond*100)&#x2F;&#x2F;0.1秒</p>
<p>6）获得当前unix时间戳和unixNano时间戳（获得随机数字）</p>
<h6 id="内置函数："><a href="#内置函数：" class="headerlink" title="内置函数："></a>内置函数：</h6><p>1）new（）：用来分配内存，主要用来分配值类型，返回的时指针</p>
<p>eg： num1:&#x3D;100&#x2F;&#x2F;num1的类型：int num1的值&#x3D;整数 </p>
<p>​         num2:&#x3D;new(int)&#x2F;&#x2F;num2的类型：*int num2的值&#x3D;地址 num2指向的值&#x3D;0</p>
<p>2）make（）：用来分配内存，主要用来分配引用类型</p>
<h6 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h6><p>1）Go中引入的处理方式：defer，panic，recover（Go中可以抛出一个panic异常，然后再defer中通过recover捕获这个异常，然后正常处理）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func test()&#123;</span><br><span class="line">       defer func()&#123;</span><br><span class="line">            err:=recover()//recover()内置函数，可以捕获到异常</span><br><span class="line">            if err !=nil&#123;//捕获到错误</span><br><span class="line">              fmt.Println(&quot;err=&quot;,err)</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;()</span><br><span class="line">       num1:=10</span><br><span class="line">       num2:=0</span><br><span class="line">       res:=num1/num2</span><br><span class="line">       fmt.Println(&quot;res=&quot;,res)</span><br><span class="line">&#125;</span><br><span class="line">func mian()&#123;</span><br><span class="line">    test()</span><br><span class="line">    fmt.Println(&quot;main()下面的代码&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）自定义错误（errors.New和panic内置函数）</p>
<p>1.errors.New(“错误说明”),会返回一个error类型的值，表示一个错误</p>
<p>2.panic内置函数，接受一个interface{}类型的值（任何值）作为参数。可以接受error类型的遍历，输出错误信息并退出程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func readConf(name string)(err error)&#123;</span><br><span class="line">   if name==&quot;config.ini&quot;&#123;</span><br><span class="line">              ....</span><br><span class="line">              return nil</span><br><span class="line">   &#125; else&#123;</span><br><span class="line">        return errors.New(&quot;读取文件错误&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">func test02()&#123;</span><br><span class="line">      err:=readConf(&quot;config.ini&quot;)</span><br><span class="line">      if err !=nil&#123;</span><br><span class="line">        panic(err)//如果读取文件发送错误，就输出这个错误并终止程序</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(&quot;test02()继续执行&quot;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h5><p>1）数组的定义</p>
<p>var 数组名 [数组大小]数据类型</p>
<p>eg:var a [5]int</p>
<p>2)四种初始化数组的方式</p>
<p>var numsArray01 [3]int &#x3D; [3]int{1,2,3}</p>
<p>var numsArray02 &#x3D; [3]int{1,2,3}</p>
<p>var numsArray03 &#x3D; […]int{6,7,8}</p>
<p>var names &#x3D; [3]string{1:”tom”,0:”jack”,2:”marry”}&#x2F;&#x2F;可以指定元素值对应的下标</p>
<p>类型推导同样适用（去掉var换成：&#x3D;）</p>
<p>3）for-range</p>
<p>for index,value:&#x3D;range array01{</p>
<p>…</p>
<p>}</p>
<p>4)注意事项</p>
<p>1.var arr []int 这时arr是个slice切片</p>
<p>2.Go的数组属值类型，在默认情况下是值传递，因此会进行值拷贝。数组间不会相互影响</p>
<p>eg：func test01(arr [3]int){</p>
<p>​      arr[0]&#x3D;88 </p>
<p>}</p>
<p> func test02(arr *[3]int){</p>
<p>​     （*arr）[0]&#x3D;88&#x2F;&#x2F;实际上arr[0]&#x3D;88也行</p>
<p>}</p>
<p>​      arr:&#x3D;[3]int{11,22,33}</p>
<p>​      test01(arr)</p>
<p>​      fmt.Println(arr)</p>
<p>&#x2F;&#x2F;test01栈中88，22，33main栈中11，22，33所以打印出来还是11，22，33</p>
<p>3.如想在其他函数中去修改原来的数组，可以使用引用传递（指针方式）</p>
<p>若将上述代码换成test02（&amp;arr），test02栈中arr为main栈中数组的地址，打印出88，22，33</p>
<p>4.长度是数组类型的一部分，在传递函数参数是需要考虑数组的长度</p>
<p>eg：right: func modify（arr [3]int）</p>
<p>wrong:func modify(arr []int)</p>
<h5 id="切片："><a href="#切片：" class="headerlink" title="切片："></a>切片：</h5><p>1）切片的基本使用</p>
<p>eg： var intArr [5]int &#x3D; […]int{1,22,33,66,99}</p>
<p>slice:&#x3D; intArr[1:3]&#x2F;&#x2F;引用intArr数组的起始下标为1，最后下标为3（但是不包含3）即slice的元素是22，33，len（slice）为2 ，cap（slice）切片的容量是动态变化的，一般为个数的两倍</p>
<p>2）slice的内存布局(一个数据结构，有三个成员type slice struct{</p>
<p>​      ptr *[2]int&#x2F;&#x2F;指向intArr的指针&amp;slice[0]&#x3D;&amp;intArr[1]</p>
<p>​      len int&#x2F;&#x2F;slice长度</p>
<p>​     cap int &#x2F;&#x2F;slice容量</p>
<p>})</p>
<p>3)使用切片的三种方式</p>
<p>1.定义一个切片，让切片去引用一个已经创建好的数组</p>
<p>2.通过make来创建切片</p>
<p>基本语法： var 切片名 []type&#x3D;make([],len,[cap])&#x2F;&#x2F;cap可选</p>
<p>3.定义一个切片，直接指定具体数组，使用原理类似于make方式</p>
<p>   eg：var slice []int &#x3D;[]int{1,3,5} &#x2F;&#x2F;此时len为3，cap也为3</p>
<p>4）切片初始化时，仍然不能越界，范围在[0-len(arr)]之间，但可以动态增长</p>
<p>5）几种简写：</p>
<p>1.var slice&#x3D;arr[0:end]简写var slice&#x3D;arr[:end]</p>
<p>2.var slice&#x3D;arr[start:len(arr)]简写var slice&#x3D;arr[start:]</p>
<p>3.var slice&#x3D;arr[0:len(arr)]简写var slice&#x3D;arr[:]</p>
<p>6)切片还可以继续切片</p>
<p>var arr [5]int &#x3D;[…]int{10,20,30,40,50}</p>
<p>slice :&#x3D; arr[1:4]&#x2F;&#x2F;20,30,40</p>
<p>slice2:&#x3D; slice[1:2]&#x2F;&#x2F;30</p>
<p>7)用append内置函数，可以对切片进行动态追加</p>
<p>eg:var slice3 []int &#x3D; []int{100，200，300}</p>
<p>slice4:&#x3D;append（slice3，400，500，600）&#x2F;&#x2F;slice4{100,200,300,400,500,600} slice3{100,200,300}</p>
<p>所以常用：slice3&#x3D;append(slice3,400,500,600)</p>
<p>也可以slice3&#x3D;append（slice3，slice3）&#x2F;&#x2F;append切片，但不能append数组</p>
<p>append底层原理分析：</p>
<p>go底层会创建新的数组newArr（扩容后大小），将slice原来包含的元素拷贝到新的数组newArr，slice再重新引用到newArr</p>
<p>8）切片的拷贝操作</p>
<p>eg: var slice4 []int &#x3D; []int{1,2,3,4,5}</p>
<p>var sllice5 &#x3D;make([]int,10)</p>
<p>copy(slice5,slice4)&#x2F;&#x2F;两个都要是切片类型，拷贝是把4的值拷贝到5来过来slice4和5互不影响，5拷贝后为1，2，3，4，5，0，0…..</p>
<p>eg：var a []int &#x3D; []int {1,2,3,4,5}</p>
<p>var slice &#x3D; make ([]int,1)</p>
<p>copy(slice,a)&#x2F;&#x2F;slice为1</p>
<h6 id="string和slice："><a href="#string和slice：" class="headerlink" title="string和slice："></a>string和slice：</h6><p>1）string底层也是一个byte数组，所以string也可以进行切片（string也有一个ptr和len）</p>
<p>2）string是不可变的，不可以通过str[0] &#x3D;’z’方式修改字符串</p>
<p>3）修改字符串，先将string转为[]byte(英文，数字)&#x2F;[]rune（中文）然后修改，重写转成str</p>
<p>eg：arr1 :&#x3D; []byte(str)</p>
<p>​        arr1[0] &#x3D; ‘z’</p>
<p>​        str &#x3D; string(arr1)</p>
<h6 id="二维数组："><a href="#二维数组：" class="headerlink" title="二维数组："></a>二维数组：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1）用法：（1）先声明再赋值</span><br><span class="line"></span><br><span class="line">  var 数组名 [][][][][大小] [大小]类型，再赋值</span><br><span class="line"></span><br><span class="line">（2）直接初始化</span><br><span class="line"></span><br><span class="line">var 数组名 [大小] [大小]类型=[大小] [大小]类型&#123;&#123;初值&#125;，&#123;初值&#125;&#125;</span><br><span class="line"></span><br><span class="line">var 数组名 [大小] [大小]类型=[...] [大小]类型&#123;&#123;初值&#125;，&#123;初值&#125;&#125;</span><br><span class="line"></span><br><span class="line">var 数组名 =[大小] [大小]类型&#123;&#123;初值&#125;，&#123;初值&#125;&#125;</span><br><span class="line"></span><br><span class="line">var 数组名 =[...] [大小]类型&#123;&#123;初值&#125;，&#123;初值&#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="map"><a href="#map" class="headerlink" title="map:"></a>map:</h5><p>1)无序的key-value的数据结构，又 称为字段或者关联数组</p>
<p>2）基本语法：</p>
<p>var 变量名 map[keytype]valuetype （声明不会分配内存，初始化需要make，分配内存后才能赋值和使用）</p>
<p>eg:var a map[string]string</p>
<p>a &#x3D; make(map[string]string,10)&#x2F;&#x2F;10为size，若不写，则默认一个大小的起始大小</p>
<p>a[“no1”]&#x3D;”宋江”</p>
<p>key可以是如bool，数字，string，指针，channel，还可以是只包含签名类型的接口，结构体，数字，通常为int，string（slice，map还有function不可以，因为这几个没法用 &#x3D;&#x3D;判断）</p>
<p>value类型基本和key一样，通常为：数字（整数，浮点数），string，map，struct</p>
<p>key是不能重复的，value是可以重复的</p>
<p>3）map可以多重map：</p>
<p>eg：var a map[string]map[string]string</p>
<p>4）使用方式</p>
<p>1）先声明，再赋值</p>
<p>var cities map[string]string</p>
<p>cities&#x3D;make(map[string]string,10)</p>
<p>2)声明直接make</p>
<p>var cities&#x3D; make(map[string]string)</p>
<p>3)声明，直接赋值</p>
<p>var cities map[string]string &#x3D;map[string]string{“no4”:”成都”}</p>
<p>4)map的删除：</p>
<p>eg：delete（cities,”no1”）</p>
<p>若要删除map所有key，可以遍历一下key，逐个删除或者map&#x3D;make(…)，make一个新的</p>
<p>5)map的查找</p>
<p>val，ok :&#x3D; cities[“no1”]</p>
<p>if ok {</p>
<p>  fmt.Printf(”有no1 key 值为%v\n“,val)</p>
<p>} else {</p>
<p>  fmt.Printf(”没有no1 key\n“)</p>
<p>}</p>
<p>6)map遍历</p>
<p>使用for-range的结构遍历，不能用for循环（key不一定是连续数字）</p>
<p>7)map切片（使map个数动态变化）</p>
<p>eg：monsters :&#x3D;[]map[string]string</p>
<p>​       monsters &#x3D; make([]map[string]string,2)</p>
<p>​    if monsters[0] &#x3D;&#x3D;nil {</p>
<p>​       monsters[0] &#x3D;make(map[string]string,2)</p>
<p>​      monsters[0] [“name”]&#x3D; “xx”</p>
<p>​     monsters[0] [“age”]&#x3D; “500”</p>
<p>}</p>
<p>   if monsters[1] &#x3D;&#x3D;nil {</p>
<p>​       monsters[1] &#x3D;make(map[string]string,2)</p>
<p>​      monsters[1] [“name”]&#x3D; “xxx”</p>
<p>​     monsters[1] [“age”]&#x3D; “400”</p>
<p>}</p>
<p>&#x2F;&#x2F;通过append函数动态增加</p>
<p>newMonster :&#x3D;map[string]string{</p>
<p>​     “name” :”xxxx”</p>
<p>​      “age” :”200”</p>
<p>}</p>
<p>monsters &#x3D;append(monsters,newMonster)</p>
<p>8)map排序</p>
<p>map默认无序（新版本有序），golang中map的排序是先将key进行排序，再根据key值遍历输出</p>
<p>排序方法：先将map的key放入切片中，再对切片排序（sort.Ints），最后遍历切片，然后按照key来输出map值</p>
<p>9）map使用细节</p>
<p>（1）容量达到后，想用map增加元素，会自动进行扩容，不会发生panic，map能动态的增长键值对</p>
<p> （2）map的value经常使用struct类型，比用map作value更好</p>
<h6 id="面向对象编程："><a href="#面向对象编程：" class="headerlink" title="面向对象编程："></a>面向对象编程：</h6><p>1）golang与传统的面向对象编程有区别，它不纯粹，golang支持面向对象编程特性</p>
<p>2）golang没有类，golang基于struct来实现面向对象OOP特性的</p>
<p>3）golang面向对象编程简洁，去掉了传统oop语言继承，方法重载，构造函数，析构函数，隐藏的this指针等</p>
<p>4）仍具有继承，封装，多态的特性，实现方式有些不同：golang没有extend，继承是通过匿名字段实现</p>
<p>5）通过接口关联，耦合性低，面向接口编程</p>
<h5 id="结构体："><a href="#结构体：" class="headerlink" title="结构体："></a>结构体：</h5><p>1）声明方式</p>
<p>（1）直接声明</p>
<p>var person Person</p>
<p>（2）{}</p>
<p>var person Person &#x3D;Person{}</p>
<p>（3）&amp;</p>
<p>var person *Person &#x3D;new（Person）</p>
<p>（4）{}</p>
<p>var person *Person&#x3D;&amp;Person{}</p>
<p>&#x2F;&#x2F;3和4方式返回的是结构体指针</p>
<p>eg：var p3 *Person&#x3D;new(Person)</p>
<p>​      (*p3).Name &#x3D;”xx”&#x2F;&#x2F;等价于p3.Name&#x3D;”xx”</p>
<p>​      (*p3).Age&#x3D;30&#x2F;&#x2F;等价于p3.Age&#x3D;30 原因：为了程序员方便，底层给p3自动加上取值运算（ *p3）</p>
<p>2）使用注意事项和细节</p>
<p>（1）结构体的所有字段在内存中是连续分布的</p>
<p>（2）结构体和其他类型进行转换时需要有完全相同的字段（名字，个数，类型）</p>
<p>（3）结构体进行type重新定义（取别名）golang认为是新的数据类型，但是相互间可以强转</p>
<p>（4）struct每个字段可以写上一个tag，tag可以通过反射机制获取，常见的使用场景就是序列化和反序列化（将struct变量进行json处理）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import “encoding/json”</span><br><span class="line"></span><br><span class="line">type Monster struct&#123;</span><br><span class="line"></span><br><span class="line">​    Name string ` json:&quot;name&quot; `</span><br><span class="line"></span><br><span class="line">​    Age int `json:“age”</span><br><span class="line"></span><br><span class="line">   Skill string `json:skill&quot;`</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line"></span><br><span class="line">​    monster :=Monster&#123;&quot;xx&quot;,500,&quot;xxx&quot;&#125;</span><br><span class="line"></span><br><span class="line">​    jsonStr,err:=json.Marshal(monster)//json.Marshal函数用到反射，将monster变量序列化为json格式</span><br><span class="line"></span><br><span class="line">  fmt.Println(&quot;jsonStr&quot;,string(jsonStr))//把Name改为name...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）创建结构体变量时指定字段值</p>
<p>（1）var stu1 Student &#x3D;student{“Tom”,10}</p>
<p>stu2 :&#x3D;Student{“tom”,10}</p>
<p>或者var stu2 Student &#x3D;Student{</p>
<p>​        Name:”Tom”,</p>
<p>​       Age:10,</p>
<p>}</p>
<p> stu2 Student :&#x3D;Student{</p>
<p>​        Name:”Tom”,</p>
<p>​       Age:10,</p>
<p>}</p>
<p>(2)返回结构体的指针类型</p>
<p>var stu1 *Student &#x3D;&amp;student{“Tom”,10}</p>
<p>var stu2 *Student &#x3D;&amp;Student{</p>
<p>​        Name:”Tom”,</p>
<p>​       Age:10,</p>
<p>}</p>
<h5 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h5><p>golang中方法是作用在指定的数据类型上的，因此自定义类型都可以有方法，而不仅仅是struct（前提是自定义类型，int这些是不能直接用的，要用也要用type interger int重命名一下）</p>
<p>eg：</p>
<p>type A struct{</p>
<p>​       Num int</p>
<p>}</p>
<p>func (a A) test(){&#x2F;&#x2F;表示A结构体有一个方法，名为test,这里面的a表示哪个A变量调用，a就是它的副本，和函数传参相似</p>
<p>​       fmt.Println(a.Num)</p>
<p>}</p>
<p>var t A</p>
<p>t.test()&#x2F;&#x2F;对的</p>
<p>test()&#x2F;&#x2F;错的</p>
<p>（1）方法的调用和传参机制和函数基本一致，不一样的地方是方法调用时会将调用方法的变量当做实参传递给方法（变量为值类型则值拷贝，若为引用类型则地址拷贝）</p>
<p>（2）结构体类型为值类型，值拷贝传递方式，若希望在方法中修改结构体变量的值，可以通过结构体指针方式处理</p>
<p>（3）golang中的方法作用在指定的数据类型，不一定需要struct，int，float32这些都行</p>
<p>（4）方法的访问范围控制的规则，和函数一样。方法名首字母小写，只能在本包访问，首字母大写，可以在本包和其他包访问</p>
<p>（5）如果一个类型实现了String（）方法，那么fmt.Println默认会调用这个类型的String（）进行输出</p>
<p>eg：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Student struct&#123;</span><br><span class="line"> Name string</span><br><span class="line"> Age int</span><br><span class="line">&#125;</span><br><span class="line">func(stu *Student) String() string&#123;</span><br><span class="line">        str :=fmt.Sprintf(&quot;Name=[%v] Age=[%v],stu.Name,stu.Age&quot;)</span><br><span class="line">        return str</span><br><span class="line">&#125;</span><br><span class="line">func main()&#123;</span><br><span class="line">     stu :=Student&#123;</span><br><span class="line">          Name : &quot;tom&quot;,</span><br><span class="line">          Age : 20,</span><br><span class="line">&#125;</span><br><span class="line">          fmt.Println(&amp;stu)//如果实现了 *student类型的String方法，则会自动调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）对于函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然，对于方法，接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样可以（这里针对的绑定的类型）</p>
<h6 id="封装（有点类似java）："><a href="#封装（有点类似java）：" class="headerlink" title="封装（有点类似java）："></a>封装（有点类似java）：</h6><p>1）将结构体，字段的首字母小写（不能导出，其他包不能使用，类似private）</p>
<p>2）给结构体所在包提供一个工厂模式的函数，首字母大写。类似一个构造函数</p>
<p>3）提供一个首字母大写的Set方法（类似于public），对属性判断并赋值</p>
<p>4）提供一个首字母大写的Get方法，用于获取属性的值</p>
<h6 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h6><p>1）嵌套匿名结构体的基本语法</p>
<p>eg：type Goods struct{</p>
<p>​     Name string</p>
<p>​     Price int</p>
<p>}</p>
<p>type Book struct{</p>
<p>​      Goods</p>
<p>​    Writer string</p>
<p>}</p>
<p>2)匿名结构体字段访问可以简化比如b继承A</p>
<p>b.A.name&#x3D;”tom”可以简化为b.name&#x3D;”tom”</p>
<p>3)当结构体和匿名结构体有相同字段或者方法时，编译器采用就近访问原则，如希望访问匿名结构体的字段和方法。可以通过匿名结构体名来区分</p>
<p>4）结构体嵌入两个匿名结构体，如两个匿名结构体中有相同的字段和方法（同时结构体本身没有同名的字段和方法），在访问时，就必须明确指定匿名结构体名字，不然报错</p>
<p>5）如果一个struct嵌套了一个有名结构体，这种就是组合，如果是组合关系，在访问组合的结构体的字段或方法时，必须带上结构体的名字</p>
<p>eg：type A struct{</p>
<p>​     Name string</p>
<p>​    Age int</p>
<p>}</p>
<p>type D struct{</p>
<p>   a A</p>
<p>}</p>
<p>比如 var d D</p>
<p>d.Name &#x3D; “jack”&#x2F;&#x2F;报错，它是组合关系，不会往A上找</p>
<p>d.a.Name &#x3D; “jack”&#x2F;&#x2F;ok</p>
<p>6）嵌套匿名结构体后，也可以在创建结构体变量（实例）时，直接指定各个匿名结构体字段的值</p>
<p>eg：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type Goods struct&#123;</span><br><span class="line">      Name string</span><br><span class="line">      Price float64</span><br><span class="line">&#125;</span><br><span class="line">type Brand struct&#123;</span><br><span class="line">     Name string</span><br><span class="line">     Address string</span><br><span class="line">&#125;</span><br><span class="line">type TV struct&#123;</span><br><span class="line">     Goods</span><br><span class="line">     Brand</span><br><span class="line">&#125;</span><br><span class="line">//type TV2 struct&#123;</span><br><span class="line">    *Goods</span><br><span class="line">    *Brand</span><br><span class="line">&#125;</span><br><span class="line">tv:=TV&#123; Goods&#123;&quot;电视机001&quot;,5000.99&#125;, Brand&#123;&quot;海尔&quot;,&quot;山东&quot;&#125;,&#125;</span><br><span class="line">//tv2:=TV2&#123; &amp;Goods&#123;&quot;电视机001&quot;,5000.99&#125;, &amp;Brand&#123;&quot;海尔&quot;,&quot;山东&quot;&#125;,&#125;用指针传更快</span><br><span class="line">//fmt.Println(*tv3.Goods,*tv3.Brand)</span><br></pre></td></tr></table></figure>

<p>7)基本类型作字段</p>
<p>type Monster struct{</p>
<p>​       Name string</p>
<p>​       Age int</p>
<p>}</p>
<p>type E struct {</p>
<p>​     Monster</p>
<p>​     int&#x2F;&#x2F;基本类型直接作为字段</p>
<p>}</p>
<p>var e E</p>
<p>e.Name&#x3D;”xx”</p>
<p>e.int&#x3D;20</p>
<h5 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h5><p>interface类型可以定义一组方法，不需要实现，并且interface不能包含任何变量，只有实现接口中的所有方法，才算实现了接口</p>
<p>基本语法：</p>
<p>type 接口名 interface{</p>
<p>​    method1（参数列表）返回值列表</p>
<p>​    method2（参数列表）返回值列表</p>
<p>   ……..</p>
<p>  }</p>
<p>1） 接口中所以方法都没有方法体</p>
<p>2）golang中接口不需要显式实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口。</p>
<p>3）接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量</p>
<p>4）只要是自定义数据类型，都可以实现接口，不仅仅是结构体类型</p>
<p>5）一个自定义可以实现多个接口</p>
<p>6）一个接口A也可以继承多个别的接口B，C。这时要实现A接口，也必须将B，C接口的方法全部实现</p>
<p>eg： type A interface{</p>
<p>​        test01()</p>
<p>}</p>
<p>type B interface{</p>
<p>​       test02() </p>
<p>}</p>
<p>type C interface{</p>
<p>​        B</p>
<p>​        A</p>
<p>​       test03() </p>
<p>}</p>
<p>只有实现了3个test才能实现C接口</p>
<p>7）interface类型默认为指针（引用类型），如果没有初始化，则会输出nil</p>
<p>8）空接口interface{}没有任何方法，所有类型都实现了空接口</p>
<p>eg：type T interface{<br>}</p>
<p>var t T&#x3D;stu&#x2F;&#x2F;ok</p>
<p>var t2 interface{} &#x3D;stu&#x2F;&#x2F;ok </p>
<p>9）接口体现的多态：</p>
<p>（1）多态参数：Usb接口案例中，Usb usb既可以接受手机变量，又可以接收相机变量，体现了多态</p>
<p>（2）多态数组：给Usb数组中，存放Phone结构体，Camera结构体变量</p>
<p>eg： var usb Arr [3]Usb</p>
<p>usbArr[0]&#x3D;Phone{“vivo”}</p>
<p>usbArr[1]&#x3D;Phone{“小米”}</p>
<p>usbArr[2]&#x3D;Camera{“尼康”}</p>
<h6 id="类型断言："><a href="#类型断言：" class="headerlink" title="类型断言："></a>类型断言：</h6><p> eg：type Point struct{</p>
<p>​       ….</p>
<p>}</p>
<p>var a interface{}</p>
<p>var point Point &#x3D;Point{1,2}</p>
<p>a&#x3D;point</p>
<p>var b Point</p>
<p>&#x2F;&#x2F;b&#x3D;a error</p>
<p>&#x2F;&#x2F;b&#x3D;a.(Point) ok类型断言：将接口变量转成具体类型的变量</p>
<p>b,ok:&#x3D;a.(Point)</p>
<p>if ok&#x3D;&#x3D; true{</p>
<p>  fmt.Println(“convert success”)</p>
<p>  fmt.Printf(“b的类型数%T 值是&#x3D;%v”，b，b)</p>
<p>} else{</p>
<p> fmt.Println(“convert fail”)</p>
<p>}</p>
<h5 id="文件操作：（os包）"><a href="#文件操作：（os包）" class="headerlink" title="文件操作：（os包）"></a>文件操作：（os包）</h5><p>1)打开：file,err:&#x3D;os.Open(“d:&#x2F;test.txt”)</p>
<p>2)关闭：err&#x3D;file.Close()&#x2F;&#x2F;常常直接打开后用defer file.Close()</p>
<p>3)读文件操作</p>
<p>(1)读文件内容并显示在终端（带缓冲的）</p>
<p>file,err:&#x3D;os.Open(“d:&#x2F;test.txt”)</p>
<p>defer file.Close()</p>
<p>reader:&#x3D;bufio.NewReader(file)&#x2F;&#x2F;默认缓冲区为4096</p>
<p>for{</p>
<p>str,err:&#x3D; reader.ReadString(‘\n’)&#x2F;&#x2F;读到一个换行就结束</p>
<p>if err&#x3D;&#x3D;io.EOF{&#x2F;&#x2F;io.EOF表示文件末尾</p>
<p>​    break</p>
<p>   }</p>
<p>}</p>
<p>(2)读取文件内容并显示在终端（ioutil异常将整个文件读入内存），适用于内存不大的情况（io&#x2F;ioutil包）</p>
<p>但这种方法已经过时了，ioutil.ReadFile(file)该改为os.ReadFile(file)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file := &quot;e:/test.txt&quot;</span><br><span class="line">content, err := os.ReadFile(file)</span><br><span class="line">if err == nil &#123;</span><br><span class="line">    fmt.Printf(&quot;%s&quot;, content)</span><br><span class="line">&#125;//注意返回的是切片</span><br></pre></td></tr></table></figure>

<p>4）读文件</p>
<p>os.OpenFile(name string,flag int,perm FileMode)(file *File,err error)&#x2F;&#x2F;第二个参数：文件打开模式（可以组合详见文档），第三个参数：权限控制（linux下有用，win下没用）</p>
<p>defer file.Close()</p>
<p>writer :&#x3D;bufio.NewWriter(file)</p>
<p>writer.WriterString(str)</p>
<p>writer.Flush()&#x2F;&#x2F;将写入缓存的内容真正写入文件中</p>
<p>5)判断文件或文件夹是否存在</p>
<p>os.Stat()函数</p>
<p>如果返回错误为nil，则文件或文件夹存在，若错误能用os.IsNotExist()判断为true,则说明文件或文件夹不存在，若干错误为其他类型，则不确定是否存在</p>
<p>6）文件拷贝</p>
<p>func Copy（dst Writer，src Reader）（written int64，err error）</p>
<p>7）命令行参数</p>
<p>os.Args是一个string的切片，用来存储所有的命令行参数</p>
<p>8）flag包解析命令行参数</p>
<p>感觉没啥用</p>
<h6 id="json-key-value"><a href="#json-key-value" class="headerlink" title="json(key-value):"></a>json(key-value):</h6><p>先将数据序列化为json字符串进行传输，接收方收到后反序列化恢复为原来的数据类型</p>
<p><a target="_blank" rel="noopener" href="https://www.json.cn/%E7%BD%91%E7%AB%99%E5%8F%AF%E4%BB%A5%E9%AA%8C%E8%AF%81json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE">https://www.json.cn/网站可以验证json格式的数据是否正确</a></p>
<p>1)json的序列化（ 一般对切片，结构体，map进行序列化，对基本类型序列化意义不大）（包来自encoding&#x2F;json)</p>
<p>data,err :&#x3D;json.Marshal(&amp;monster)&#x2F;&#x2F;按引用方式传递</p>
<p>if err !&#x3D;nil{</p>
<p>​       fmt.Printf(“err&#x3D;%v\n”,err) </p>
<p>}</p>
<p>fmt.Printf(“monster序列化后&#x3D;%v\n”,string(data))</p>
<p>2)json的反序列化</p>
<p>str :&#x3D;”{…..}”&#x2F;&#x2F;获得的json字符串</p>
<p>var monster Monster</p>
<p>err :&#x3D;json.Unmarshal([]byte(str),&amp;monster)&#x2F;&#x2F;反序列化map前，不需要make，make被封装到Unmarshal函数中了，序列化时一定要记着make</p>
<p>if err !&#x3D; nil{</p>
<p>fmt.Println(“err”)</p>
<p>}</p>
<p>fmt.Printf(“反序列化后monster&#x3D;%v\n”,monster)</p>
<h5 id="go中进行单元测试："><a href="#go中进行单元测试：" class="headerlink" title="go中进行单元测试："></a>go中进行单元测试：</h5><p>cal_test.go:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import(</span><br><span class="line">  &quot;testing&quot;</span><br><span class="line">)</span><br><span class="line">func TestAddUpper(t *testing.T)&#123;</span><br><span class="line"> res :=addUpper（10）</span><br><span class="line"> if res !=55&#123;</span><br><span class="line">       t.Fatalf(&quot;wrong&quot;)</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> t.Logf(&quot;right&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cal.go:</p>
<p>func addUpper(i int) int{</p>
<p>…….</p>
<p>}</p>
<p>总结：test框架将xxx__test.go文件引入import</p>
<p>main(){</p>
<p>&#x2F;&#x2F;2.调用TestXxx函数</p>
<p>}</p>
<p>注意事项：</p>
<p>1）测试用例文件名必须以_test.go结尾</p>
<p>2）测试用例函数必须以Test开头，而且后面那个字母不能是a-z</p>
<p>3）形参类型必须是*testing.T</p>
<p>4)运行指令：</p>
<p>（1）go test(错误才输出日志)</p>
<p>   (2) go test -v（正确错误都输出日志）</p>
<p>5）常用t.Fatal和t.Logf</p>
<p>6)测试单个文件，一定要带上被测试的源文件</p>
<p>go test -v cal_test.go cal.go</p>
<p>7)测试单个方法</p>
<p>go test -v -test.run TestAddUpper</p>
<h5 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine:"></a>goroutine:</h5><p>1)go协程与go主线程</p>
<p>主线程可以理解为线程或者进程，一个go线程上们可以起多个协程，协程换句话说是轻量级的线程</p>
<p>协程特点：有独立的栈空间，共享程序堆空间，调度由用户控制，协程是轻量级的线程</p>
<p>2）协程写法的简单暴力</p>
<p>func test（）{</p>
<p>​      …..</p>
<p>}</p>
<p>fuc main(){</p>
<p>  go test()&#x2F;&#x2F;开启协程了</p>
<p>…….</p>
<p>}</p>
<p>3）主线程是一个物理线程，直接作用在cpu上。是重量级的，非常耗费cpu资源，协程是轻量级的线程，是逻辑态</p>
<p>4）MPG模式</p>
<p>M：操作系统的主线程</p>
<p>P：协程执行需要的上下文</p>
<p>G：协程</p>
<p>5）golang中设置允许cpu数量（runtime包）</p>
<p>cpuNum :&#x3D; runtime.NumCPU()&#x2F;&#x2F;查看cpu个数</p>
<p>rumtime.GOMAXPROCS(cpuNum-1)&#x2F;&#x2F;设置最多能用多少个cpu</p>
<p>6）加锁解锁（sync包）</p>
<p>var lock sync.Mutex</p>
<p>lock.Lock()</p>
<p>xxxxx</p>
<p>lock.Unlock()</p>
<h6 id="channel："><a href="#channel：" class="headerlink" title="channel："></a>channel：</h6><p>1）为什么需要channel：主线程等待所有goroutine全部完成实际很难确定，只能估算，而且利用加锁同步实现通讯不利于多个协程对全局变量的读写操作</p>
<p>2）channel本质为队列，先进先出，channel具有数据类型，对应数据类型进对应管道</p>
<p>3）channel的基本使用：</p>
<p>var 变量名 chan 数据类型&#x2F;&#x2F;channel为引用类型，必须用make进行初始化</p>
<p>var intChan chan int</p>
<p>intChan &#x3D;make(chan int,3)</p>
<p>intChan&lt;- 10&#x2F;&#x2F;向管道写入数据</p>
<p>num:&#x3D;211</p>
<p>intChan&lt;- num</p>
<p>num2 :&#x3D;&lt;- intChan&#x2F;&#x2F;从管道中取数据</p>
<p>4）channel的关闭</p>
<p>关闭了只能读，不能写</p>
<p>close（intChan）</p>
<p>5）channel的遍历</p>
<p>支持for-range遍历，在遍历时，channel没有关闭，则会出现deadlock错误，如果channel已经关闭，则会正常遍历数据。</p>
<p>close(intChan2)</p>
<p>for v:&#x3D;range intChan2 {</p>
<p>​    fmt.Println(“v&#x3D;”,v)</p>
<p>}</p>
<p>6）channel可以声明为只读或者只写</p>
<p>只写： var chan2 chan&lt;- int</p>
<p>chan2 &#x3D;make(chan int,3)</p>
<p>chan2&lt;- 20</p>
<p>只读： var chan3 &lt;-chan int</p>
<p>chan3 &#x3D;make(chan int ,3)</p>
<p>num2 :&#x3D; &lt;- chan3</p>
<p>7)使用select解决从管道取数据的阻塞问题（感觉没啥用）（不好确定什么时候关闭该管道时可以这样做）</p>
<p>select{         </p>
<p>​         case v :&#x3D;&lt;-管道：</p>
<p>​          语句</p>
<p>​        default：</p>
<p>​        语句</p>
<p>}</p>
<p>8）goroutine中使用recover，解决协程中出现panic的问题：（有点类似Java中的try-catch），可以不影响整个进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func test() &#123;</span><br><span class="line">  defer func()&#123;</span><br><span class="line">      if err :=recover();err !=nil&#123;</span><br><span class="line">      fmt.Println(&quot;test()error&quot;,err)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">var myMap map[int]string</span><br><span class="line">myMap[0] = &quot;golang&quot;//wrong</span><br><span class="line">&#125;</span><br><span class="line">func main()&#123;</span><br><span class="line">      go test()</span><br><span class="line">      go sayHello()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Zhen Xie</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2023/10/08/Golang%E5%AD%A6%E4%B9%A0/">http://example.com/2023/10/08/Golang%E5%AD%A6%E4%B9%A0/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"># 区块链</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/11/13/%E8%B7%A8%E9%93%BE%E5%8E%9F%E5%AD%90%E6%80%A7/">跨链原子性</a>
            
            
            <a class="next" rel="next" href="/2023/09/12/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Zhen Xie | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>