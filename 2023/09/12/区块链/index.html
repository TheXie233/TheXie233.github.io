<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Zhen Xie">





<title>区块链 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>
<script>
    !
    function() {
    function n(n, e, t) {
    return n.getAttribute(e) || t
    }
    function e(n) {
    return document.getElementsByTagName(n)
    }
    function t() {
    var t = e("script"),
    o = t.length,
    i = t[o - 1];
    return {
    l: o,
    z: n(i, "zIndex", -1), //置于主页面背后
    o: n(i, "opacity", .5), //线条透明度
    c: n(i, "color", "0,0,0"), //线条颜色
    n: n(i, "count", 100) //线条数量
    }
    }
    function o() {
    a = m.width = window.innerWidth ||
    document.documentElement.clientWidth || document.body.clientWidth,
    c = m.height = window.innerHeight ||
    document.documentElement.clientHeight || document.body.clientHeight
    }
    function i() {
    r.clearRect(0, 0, a, c);
    var n, e, t, o, m, l;
    s.forEach(function(i, x) {
    for (i.x += i.xa, i.y += i.ya, i.xa *= i.x > a || i.x < 0 ? -1 :
    1, i.ya *= i.y > c || i.y < 0 ? -1 : 1, r.fillRect(i.x - .5, i.y - .5, 1,
    1), e = x + 1; e < u.length; e++) n = u[e],
    null !== n.x && null !== n.y && (o = i.x - n.x, m = i.y - n.y, l
    = o * o + m * m, l < n.max && (n === y && l >= n.max / 2 && (i.x -= .03 * o,
    i.y -= .03 * m), t = (n.max - l) / n.max, r.beginPath(), r.lineWidth = t /
    2, r.strokeStyle = "rgba(" + d.c + "," + (t + .2) + ")", r.moveTo(i.x, i.y),
    r.lineTo(n.x, n.y), r.stroke()))
    }),
    x(i)
    }
    var a, c, u, m = document.createElement("canvas"),
    d = t(),
    l = "c_n" + d.l,
    r = m.getContext("2d"),
    x = window.requestAnimationFrame || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(n) {
    window.setTimeout(n, 1e3 / 45)
    },
    w = Math.random,
    y = {
    x: null,
    y: null,
    max: 2e4
    };
    m.id = l,
    m.style.cssText = "position:fixed;top:0;left:0;z-index:" + d.z +
    ";opacity:" + d.o,
    e("body")[0].appendChild(m),
    o(),
    window.onresize = o,
    window.onmousemove = function(n) {
    n = n || window.event,
    y.x = n.clientX,
    y.y = n.clientY
    },
    window.onmouseout = function() {
    y.x = null,
    y.y = null
    };
    for (var s = [], f = 0; d.n > f; f++) {
    var h = w() * a,
    g = w() * c,
    v = 2 * w() - 1,
    p = 2 * w() - 1;
    s.push({
    x: h,
    y: g,
    xa: v,
    ya: p,
    max: 6e3
    })
    }
    u = s.concat([y]),
    setTimeout(function() {
    i()
    },
    100)
    } ();
    </script>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">TheXie&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">TheXie&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">区块链</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Zhen Xie</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 12, 2023&nbsp;&nbsp;20:21:21</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Lab/">Lab</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h4 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h4><h5 id="区块链的划分："><a href="#区块链的划分：" class="headerlink" title="区块链的划分："></a>区块链的划分：</h5><p>公有链：任何人都可读取，可发生交易且交易能获得有效确认，任何人都能参与共识。（以代币给予挖矿者激励）</p>
<p>联盟链：共识过程受预选节点控制，或者允许每个人都可读取。（可以不设）</p>
<p>私有链：写入权限仅在一个组织中。读取权限或者对外开放。（可以不设）</p>
<h5 id="区块链如何运行："><a href="#区块链如何运行：" class="headerlink" title="区块链如何运行："></a>区块链如何运行：</h5><ol>
<li><p>交易并将交易广播</p>
</li>
<li><p>记账者记录一段时间发生的所有交易，打包为一个区块（记账者竞争解决哈希函数谜题）</p>
</li>
<li><p>区块按时间顺序串联</p>
</li>
</ol>
<h5 id="区块链结构："><a href="#区块链结构：" class="headerlink" title="区块链结构："></a>区块链结构：</h5><p>块头（头哈希，父哈希）块体（交易，时间戳）</p>
<h5 id="交易模型："><a href="#交易模型：" class="headerlink" title="交易模型："></a>交易模型：</h5><p>传统：只看余额，加减账户的余额数字</p>
<p>UTXO（未花费的交易输出）：只记录交易过程，下一笔交易的输出必须是之前交易的输出。</p>
<h5 id="分叉与最长链原则："><a href="#分叉与最长链原则：" class="headerlink" title="分叉与最长链原则："></a>分叉与最长链原则：</h5><p>1.少数服从多数，更多认可的就是公认的。</p>
<p>2.更多记账者在认可的区块后面跟随记账，经过时间长度会长于另一条。</p>
<p>3.等待6个区块来确定一笔交易得到最终确认。</p>
<h5 id="梅克尔树："><a href="#梅克尔树：" class="headerlink" title="梅克尔树："></a>梅克尔树：</h5><p>交易先每个生成一个hash，hash再两两生成一个hash，最后生成一个根节点（每个区块中的交易只需通过这一个交易产生的哈希进行验证，而不需要关注其他的交易）</p>
<h5 id="共识机制（拜占庭将军问题）："><a href="#共识机制（拜占庭将军问题）：" class="headerlink" title="共识机制（拜占庭将军问题）："></a>共识机制（拜占庭将军问题）：</h5><p>通过投票来达成一致策略，要么共同进攻或共同撤退</p>
<ol>
<li>非拜占庭容错模型–适用于分布式数据库</li>
</ol>
<p>错误类型：消息丢失，重复，延时，服务器宕机，通信协议不可靠</p>
<ol start="2">
<li>拜占庭容错模型—适用于分布式账本（区块链）</li>
</ol>
<p>错误类型：非拜占庭容错，攻击者篡改消息内容</p>
<p>解决思路：a）提高恶意节点成本，降低错误出现的概率</p>
<p>B）允许一定比例恶意节点出现，依然实现账本一致</p>
<ol start="3">
<li>经济模型</li>
</ol>
<p>错误类型：购买大量硬件资源视图发动攻击，贿赂其他节点发动合谋攻击</p>
<h5 id="共识特点："><a href="#共识特点：" class="headerlink" title="共识特点："></a>共识特点：</h5><h6 id="随机性："><a href="#随机性：" class="headerlink" title="随机性："></a>随机性：</h6><p>随机选择记账者，提高作恶者成本（连续作恶，大比例作恶）</p>
<p>随机数不可被预测，不可控</p>
<h6 id="抗女巫攻击："><a href="#抗女巫攻击：" class="headerlink" title="抗女巫攻击："></a>抗女巫攻击：</h6><p>抵制刷小号</p>
<p>增加门槛：计算力，资源</p>
<h6 id="激励机制："><a href="#激励机制：" class="headerlink" title="激励机制："></a>激励机制：</h6><p>奖励诚实的</p>
<p>对不诚实的作恶者的反激励机制</p>
<h5 id="工作量证明Pow"><a href="#工作量证明Pow" class="headerlink" title="工作量证明Pow"></a>工作量证明Pow</h5><p>随机性：谜题友好</p>
<p>抗女巫攻击：算力</p>
<p>激励机制：区块奖励+手续费</p>
<h5 id="权益证明PoS"><a href="#权益证明PoS" class="headerlink" title="权益证明PoS"></a>权益证明PoS</h5><p>随机性：VDF，VRF等随机数</p>
<p>抗女巫攻击：锁定代币</p>
<p>激励机制：区块奖励+手续费</p>
<h5 id="授权权益证明DPoS"><a href="#授权权益证明DPoS" class="headerlink" title="授权权益证明DPoS"></a>授权权益证明DPoS</h5><p>PoS；币给区块投票</p>
<p>DPoS：币给节点投票</p>
<p>通过锁定代币获得投票权，投票给节点候选人，排名靠前的节点代为行使出块权力，轮流出块。（专事专人）</p>
<h5 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h5><p>选出一位广播决定，其余将军返回反馈，若有三分之二的认为诚实，则得到一个强一致的结果，不会存在分叉</p>
<p>最多容忍N&#x3D;3f+1</p>
<h6 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h6><p>请求阶段：主节点接受客户端请求</p>
<p>Pre-prepare:主节点对信息编号验证后发送Pre-prepare消息广播</p>
<p>Prepare：普通节点收到信息后与Pre-prepare消息验证，并将请求的信息广播给其他普通节点。每个节点继续接受Prepare消息并进行合法性验证（包括签名、视图编号正确性等）</p>
<p>Commit：当某个节点接收到验证通过的2f条消息时，该节点将进入提交阶段，，并广播Commit消息给其他节点。每个进入提交阶段的节点继续接收Commit消息并进行合法性验证，(为什么不是2f+1：这个1是Pre-prepare阶段主节点发送的Pre-prepare消息)</p>
<p>Reply：当接收并验证2f+1个节点时。这些达成共识的节点执行request，然后进入回复阶段并发送Reply消息给客户端；当客户端接收f+1条Reply消息时，表示回复成功，达成共识。</p>
 <img src="C:\Users\the xie\Desktop\v2-451165a9d6de89d6b6f0e7468b71049b_720w.png" alt="v2-451165a9d6de89d6b6f0e7468b71049b_720w" style="zoom:50%;" />

<h6 id="视图切换算法（大于F个诚实节点没收到或收到错误消息，则发起视图更换）："><a href="#视图切换算法（大于F个诚实节点没收到或收到错误消息，则发起视图更换）：" class="headerlink" title="视图切换算法（大于F个诚实节点没收到或收到错误消息，则发起视图更换）："></a>视图切换算法（大于F个诚实节点没收到或收到错误消息，则发起视图更换）：</h6><p>1.若其他节点认为主节点有问题，则广播视图切换请求view-change，其中P包括了prepared（m,v,n,i）&#x3D;true的信息（那些已经准备好的节点）。</p>
<p>2.p&#x3D;v+1（下一个新选的主节点）若收到其他（不含自己）的2f个view-change，则作为主节点发起视图切换，广播new-view，消息内容O为view-change中P中所有的request创建一个新的pre-prepare消息（这些request虽然处于不同view，但分配编号仍然不变），若没有准备好的，则创建一个null request的pre-prepare消息。</p>
<p>3.其他节点收到new-view后，对消息进行验证，若验证通过，则选择最新stable checkpoint。并执行集合O中的pre-prepare消息，若节点已经执行过了request，则不再执行request，但prepared，commit以及reply都需要再次发送。</p>
<h6 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h6><ol>
<li></li>
</ol>
<h6 id=""><a href="#" class="headerlink" title=""></a><img src="file:///C:\Users\the xie\Documents\Tencent Files\577037595\Image\C2C\5`4P3OJRYATF9GI`RC{LSFV.png" alt="img" style="zoom:67%;" /></h6><ol start="2">
<li></li>
</ol>
<p><img src="file:///C:\Users\THEXIE~1\AppData\Local\Temp\ksohtml9064\wps2.jpg" alt="img"></p>
<ol start="3">
<li></li>
</ol>
<p><img src="file:///C:\Users\THEXIE~1\AppData\Local\Temp\ksohtml9064\wps1.jpg" alt="img"></p>
<h4 id="纠删码技术"><a href="#纠删码技术" class="headerlink" title="纠删码技术"></a>纠删码技术</h4><h5 id="分组码："><a href="#分组码：" class="headerlink" title="分组码："></a>分组码：</h5><p>分为不同块，针对每一块独立编码。用（k，n）表示，原始数据块包括k个信息码元，添加r&#x3D;n-k个冗余的监督码元。</p>
<p>XOR编码，RS编码</p>
<h5 id="卷积码："><a href="#卷积码：" class="headerlink" title="卷积码："></a>卷积码：</h5><p>有记忆，且于原始数据库相关，与之前的编码块也相关</p>
<h5 id="用于分布式存储系统的纠删码："><a href="#用于分布式存储系统的纠删码：" class="headerlink" title="用于分布式存储系统的纠删码："></a>用于分布式存储系统的纠删码：</h5><p>RS编码：数据传输，广播，云存储技术</p>
<p>阵列纠删码（RAID）：镜像或者存储奇偶校验信息的方法，常用于磁盘存储</p>
<p>低密度奇偶校验纠删码（LDPC）：保障数据存储的可靠性，但效率更低，用于通信，视频，音频编码。</p>
<h5 id="RS编码："><a href="#RS编码：" class="headerlink" title="RS编码："></a>RS编码：</h5><p>基于域元素多项式运算</p>
<p>以字为单位，原始数据先切分至字长为（8或16位）的字</p>
<p>范德蒙RS编码</p>
<p>柯西RS编码</p>
<h4 id="数字签名技术"><a href="#数字签名技术" class="headerlink" title="数字签名技术"></a>数字签名技术</h4><p>非对称密码体制，发送者用私钥加密，接收者用对于的公钥解密数据</p>
<h5 id="区块链中常用门限签名：分布式的多方签名协议："><a href="#区块链中常用门限签名：分布式的多方签名协议：" class="headerlink" title="区块链中常用门限签名：分布式的多方签名协议："></a>区块链中常用门限签名：分布式的多方签名协议：</h5><p>对于一个门限签名（t，n）-TS，指由n个成员组组成的一个签名群体，群体内任意大于等于t个诚实的成员组合可以用群私钥进行签名，成员不能冒名签名，但可以用群公钥进行签名验证，流程如下：</p>
<p>1.生成公私钥。所以参与者共同生成一份群公私钥，每个参与者获得一份相同的公钥和自己的一部分私钥。</p>
<p>2。签名阶段。对于公共待签名消息，签名者将签名结果发送给中间管理者，它将所有签名汇集得到完整签名。</p>
<p>3.验证阶段。使用公钥进行签名验证。</p>
<h3 id="基于-RS-编码的联盟链存储方案"><a href="#基于-RS-编码的联盟链存储方案" class="headerlink" title="基于 RS 编码的联盟链存储方案"></a><strong>基于</strong> RS <strong>编码的联盟链存储方案</strong></h3><h4 id="数据分配与编码："><a href="#数据分配与编码：" class="headerlink" title="数据分配与编码："></a>数据分配与编码：</h4><p>对每个单独的区块进行数据分片，分片数量由区块大小和系统节点数量决定。</p>
<p>以二级分片为例：</p>
<p>确定一级分片数量r，保证二级分片大小l再1kb内。每个以及分片分割成二级分片数量k不小于N-2F，如下图：</p>
<p>![image-20230725144909493](C:\Users\the xie\AppData\Roaming\Typora\typora-user-images\image-20230725144909493.png)</p>
<p>一级分片数量为r，二级分片数量为k，区块大小为T，二级分片大小为l，T&#x3D;r * k * l&#x3D;r * （N-2F）由此可算出分片数量。B（h）&#x3D;{B1（h），B2（h），······Br（h）}对于每个一级分片，又有Bi（h）&#x3D;{bi，1（h），bi，2（h）······bi，k（h）}分片完后，对每个一级分片进行独立的RS编码</p>
<p><img src="file:///C:\Users\THEXIE~1\AppData\Local\Temp\ksohtml24312\wps1.jpg" alt="img"></p>
<p>编码后的N个编码值，由N个节点对应保存。节点Ns对于区块B（h）的集合为</p>
<p>Fh（s）&#x3D;{fh，1（s），······fh，r（s）}</p>
<p>拓展至整个链，假设有t个区块则需要t*r个编码值：</p>
<p>fh1，1（s）,······fh1，r（s），······，fht，1（s），······fht，r（s）</p>
<h4 id="数字签名认证："><a href="#数字签名认证：" class="headerlink" title="数字签名认证："></a>数字签名认证：</h4><p>采用无证书的聚合签名方案CLAS方案，嵌入PBFT协议的Commit阶段进行，每个节点对B（h）所有编码值进行签名，然后和commit消息一起全网广播。节点受到其他节点的commit消息时，先验证签名合法性，再证明编码值是否正确。直到收到F+1个来自不同节点的commit，然后将签名进行聚合。然后再将这一个一级分片的签名进行迭代聚合，得到单个聚合签名，作为区块B（h）编码值集合Fh（s）的认证。当完成签名认证后，可以丢弃除去自己需要保存的对应编码值外的所有编码值。</p>
<p>![image-20230725144224540](C:\Users\the xie\AppData\Roaming\Typora\typora-user-images\image-20230725144224540.png)</p>
<p>![image-20230725145650644](C:\Users\the xie\AppData\Roaming\Typora\typora-user-images\image-20230725145650644.png)</p>
<h5 id="数据恢复："><a href="#数据恢复：" class="headerlink" title="数据恢复："></a>数据恢复：</h5><p>![image-20230725151048094](C:\Users\the xie\AppData\Roaming\Typora\typora-user-images\image-20230725151048094.png)</p>
<p>主节点收到客户端的请求，先广播decode消息给所有从节点，从节点们收到decode消息后将存储的对应编码值集合以及数字签名发送给主节点。收到N-2F个来自不同从节点的有效编码值集合后，根据索引i带入对应的以及分片RS编码生成多项式fh，i（X）中，从而得到（N-2F）元线性方程，计算解得二级分片集合{bi，1（h），······，bi，k（h）}，再根据二级分片的索引i进行链接得到一级分片Bi（h）；再将一级分片根据他们的索引i进行链接，得到原始区块B（h）。</p>
<h5 id="系统重初始化："><a href="#系统重初始化：" class="headerlink" title="系统重初始化："></a>系统重初始化：</h5><p>考虑有新节点加入或者现有节点退出：</p>
<h6 id="1-新节点加入："><a href="#1-新节点加入：" class="headerlink" title="1.新节点加入："></a>1.新节点加入：</h6><p>节点个数为N+1，此时应用（N-2F，N+1）-RS编码方案仍能满足PBFT协议容错前提。</p>
<h6 id="2-现有节点退出："><a href="#2-现有节点退出：" class="headerlink" title="2.现有节点退出："></a>2.现有节点退出：</h6><p>分两个情况：</p>
<p>（1）节点数量N’&gt;&#x3D;N+1,此时节点数量仍然不小于N，因此（N-2F，N‘-1）-RS编码有效。（有节点富裕）</p>
<p>（2）节点数等于N，此时原编码方案不能保证数据能成功恢复，此时节点数量为N-1，拜占庭节点上限为F’&#x3D;（N-1-1）&#x2F;3，则更新为（（N-1）-2F‘，N-1）-RS。</p>
<p>思考：为什么加节点不需要改拜占庭节点，减去却要改？</p>
<p>加节点时你之前都能满足编码要求，之前模型是要求上限F，现在改了后现存拜占庭节点不会超过上限，所以不需要改，而减去后上限是减少了，现存的拜占庭节点有可能就超上限了，所以需要改。</p>
<h6 id="重初始化流程："><a href="#重初始化流程：" class="headerlink" title="重初始化流程："></a>重初始化流程：</h6><p>新节点：</p>
<p>首先，Nn+1加入系统后，新节点会全网广播对于区块B（h）的decode消息，现有节点收到decode消息后，将其储存的对于区块B（h）的编码值集合于相应的签名集合发送非新节点Nn+1。当新节点收到N-2F个有效编码值后，可以通过RS解码恢复得到区块B（h）所有的二级分片。解码后，新节点Nn+1应用（N-2F，N+1）-RS计算得到新的编码值集合，并对其签名得到签名集合（N+1），新节点再通过re-initialize消息，将二级分片集合与签名集合向全网广播。重新编码过程中中前N个节点所对应保存的编码值集合不变，仅新节点须保持其对于的编码值集合Fh（N+1）。根据RS生成多项式计算新节点Nn+1对于编码值集合Fh（N+1）并对其签名得签名集合，将签名集合发送给新节点。当新节点收到F+1个不同节点有效签名后，将签名聚合成单个签名，与编码值集合一同存储。同样的，原有节点收到新节点的签名集合时，从中取出对自己编码值集合的对应签名，与现有聚合签名再一次聚合。当系统重初始化流程完成后，新节点可丢弃冗余 的编码值及其信息。</p>
<p>简单来说就是先解码，获得信息后根据新的编码方式进行编码，并将此发给现有节点，现有节点收到后更新，并返回签名给新节点，当新节点满足F+1时，则完成重初始化。</p>
<p>![image-20230725164622512](C:\Users\the xie\AppData\Roaming\Typora\typora-user-images\image-20230725164622512.png)</p>
<p>若有一个以上的节点同时加入，重初始化可以并发执行，第一个启动重初始化的节点负责解码一级重新编码，而后新节点仅需负责根据新的RS编码方案计算编码值并签名。</p>
<h6 id="现有节点退出系统"><a href="#现有节点退出系统" class="headerlink" title="现有节点退出系统:"></a>现有节点退出系统:</h6><p>  对于N’&gt;N+1时，即使退出节点数仍然不小于N，所以（N-2F，N’-1）-RS编码方案仍然可以确保所有数据可被恢复。此时退出的节点仅需删除自己保存的编码值，签名等信息并退出系统即可，其余节点不须做额外的工作。</p>
<p>而对于N‘&#x3D;N的情况，需要更新编码方案为（（N-1）-2F’，N-1）-RS；此时，所有节点需要在当前视图的主节点负责下，进行解码与重新编码验证。（全部重新来过）</p>
<h5 id="节点行为监督："><a href="#节点行为监督：" class="headerlink" title="节点行为监督："></a>节点行为监督：</h5><p>每个节点有自己的信誉值，基于节点作恶行为以及正确参与协议运行的次数进行实时更新，每个节点实时维护一个动态数组，记录各个节点当前信誉值。节点主要通过对数字签名的验证来发现其他节点的恶意行为，假设Ns发出的消息不合法，则会广播detected消息指明节点Ns伪造消息。若收到F+1个指明节点作恶的detected消息时，将 更新Ns中的信誉值。</p>
<p>系统初始化时，管理员定一个信誉值下限，运行时定期监测各节点信誉值，若低于则移除系统。但只要当前节点数N‘大于应用的编码方案（N-2F，N）-RS中的N，才会移除节点，避免额外的解码与重编码过程。节点还会根据信誉值划分为不同的安全等级，更换主节点视图时可参考其安全等级执行轮换算法。</p>
<p>节点行为监督算法：当前视图的主节点广播inspect消息。当节点Ns收到主节点的inspect消息后，查询信誉值数组，并将所以信誉值低于下限的节点序号打包成集合，签名并生成聚合签名，一并回复给主节点。主节点收到至少N-2F个回复消息后，查询序号列表并将所以出现在至少F+1个列表的序号打包成集合malicious。集合malicious中的节点将被移除系统。</p>
<h5 id="安全性于活性（为什么取N-2F）："><a href="#安全性于活性（为什么取N-2F）：" class="headerlink" title="安全性于活性（为什么取N-2F）："></a>安全性于活性（为什么取N-2F）：</h5><p>RS编码最多容忍n-k个编码块丢失，考虑最坏情况，F个拜占庭节点，至少n-F个编码块存储再非拜占庭节点上，n-F&gt;&#x3D;k，所以n-k&gt;&#x3D;F，至少需要F个冗余编码快，才能恢复数据。由于主节点可能是拜占庭节点，系统存在至多F个拜占庭节点，F个没收到主节点pre-prepare消息而保持沉默或伪造的pre-prepare消息而发送错误的prepare消息，因此至少N-2F个诚实节点存储正确。相似的，在系统重初始化阶段也类似，只能保证至少收到N-2F个正确的</p>
<h4 id="关于实验："><a href="#关于实验：" class="headerlink" title="关于实验："></a>关于实验：</h4><h5 id="Tendermint："><a href="#Tendermint：" class="headerlink" title="Tendermint："></a>Tendermint：</h5><h6 id="封装的底层："><a href="#封装的底层：" class="headerlink" title="封装的底层："></a>封装的底层：</h6><p>将区块链一般性框架”网络-共识-应用“中的底下两层网络与共识封装成Tendermint Core，同时提高ABCI接口与应用交互。（类似操作系统？）</p>
<h6 id="共识算法："><a href="#共识算法：" class="headerlink" title="共识算法："></a>共识算法：</h6><p>PoS+BFT</p>
<p>确定一个区块，通过一个回合round，由propose，prevote和precommit，第一个由选举共识实现，后两个由主链共识实现。</p>
<p>选举共识-PoS：</p>
<p>从候选人中选择一个出块人，采取非阻塞轮询策略（出块人的选择概率与候选人的投票权重正相关）</p>
<p>主链共识-BFT：<br>采用优化的BFT拜占庭共识协议：</p>
<p>简化了PBFT，仅使用两轮投票达成共识</p>
<p>1.预投票pre-vote</p>
<p>2.预提交pre-commit</p>
<p>超过三分之二的投票才成功</p>
<p>最终一致性,不回出现分叉</p>
<p>共识容错率：容忍三分之一的作恶节点</p>
<p>ABCI-Tendermint与区块链应用通信法则</p>
<p>Tendermint通过ABCI区块链应用接口与区块链应用联系，特点是:</p>
<p>使用socket协议通信</p>
<p>ABCI标志包含多种交易类型：<br>DeliverTx：每笔交易都通过其传送</p>
<p>CheckTx：仅用于验证交易</p>
<p>CommitTx：用于应用状态的加密保证</p>
<h5 id="Tendermint-BFT详解："><a href="#Tendermint-BFT详解：" class="headerlink" title="Tendermint-BFT详解："></a>Tendermint-BFT详解：</h5><h6 id="Round-based协议"><a href="#Round-based协议" class="headerlink" title="Round-based协议"></a>Round-based协议</h6><p>五个步骤不断循环执行：</p>
<p>NewHeight-&gt;Propose-&gt;Prevote-&gt;Precommit-&gt;Commit</p>
<p>中间的三个步骤为一个Round<br>步骤如下：</p>
<p>1.进入新的高度阶段，等待进入Propose阶段</p>
<p>2.Propose阶段，选举Proposer，然后Proposer提交一个Proposal，进入Prevote阶段</p>
<p>3.Prevote阶段Validators对收到的Proposal进行prevote投票，当达到三分之二的prevote投票后进入Precommit阶段</p>
<p>4.Precommit阶段进行Precommit投票，当达到三分之二的投票后进入Commit阶段；未达到则重进Propose即Step2</p>
<p>5Commit旧节点准备好新的高度以及广播新的状态给节点，进入Step1</p>
<p>Proposal：</p>
<p>Proposer从Validators中选举，Validator的注册通过编写配置文件genesis.json在区块链创世区块中配置</p>
<p>选择规则：Round-robin</p>
<p>初始化Validators后，全部节点会将Validator数据备份至本地。</p>
<p>全网从Validator循坏排序数组的0位置开始指定Proposer，每次新的高度依次向后指定，达到最后时从0重新开始，如果Proposer部分连接或异常，则会跳过该节点向下指定。Validator循环排序数组中的Validator怎么选举的饿呢？根据Validator的votingPower来决定顺序，votingPower越大越容易被选中，每个votingPower由其质押的资金stake1：1恒定</p>
<p>初始化后每轮votingPower都会更新：</p>
<p>本轮未选中的Validator本轮后其votingPower增加其初始化的stake即votingPower&#x3D;votingPower+stake</p>
<p>本轮选中的Validator本轮后其votingPower减少为其他Validator的stake之和：</p>
<p>votingPower&#x3D;votingPower-stake和</p>
<p><u>Round-robin策略的问题在于下一个Proposer可以被预测到容易引发对于特点单点主机的DDos攻击，所以还需要隐藏Validator节点的Ip地址</u></p>
<p>Prevote：Validator不断监听是否有新的Proposal区块，每个Validator进行Prevote阶段的投票之前，要先判断自己是否锁定在上一轮的Proposal区块上：（1）是则继续签名广播上一轮锁定的Proposal区块并广播Prevote投票（2）否则签名广播当前轮Proposal区块并广播prevote投票（3）某些原因导致Validator没有锁定任一Proposal区块，则签名广播一个空的prevote投票</p>
<p>通过不同轮次将统一网络中的Validator区分开避免多次prevote投票，prevote投票与Proposal区块一一对应</p>
<p>Precommit：</p>
<p>Validator会收集prevote投票：</p>
<p>达到三分之二的prevote投票，则为这个区块签名广播precommit投票，并且Validator锁定在此Proposal区块上，同时释放之前锁定的区块，一个Validator智能锁定一个区块</p>
<p>若收到达到三分之二的空的prevote投票，则释放之前锁定的所有区块</p>
<p>若没有收集到超过三分之二的任何prevote投票，则不会锁定任何区块。处于锁定状态的Validator会为锁定的区块手机prevote投票，并将投票打包放入proof-of-lock。</p>
<p>Commit：</p>
<p>如果Validator收到超过三分之二的precommit投票，则进入commit阶段，否则进入下一轮Proposal阶段。</p>
<p>1.Validator收到了被全网commit的区块，Vlidator会为这个区块广播commit投票</p>
<p>2.Validator需要为precommit的区块收集超过三分之二的commit投票。满足条件，则进入NewHeight阶段。进入新一高度（一个高度可能对应多个轮次）</p>
<p>为什么可以不分叉：</p>
<p>加上了锁的机制，在下一轮中，每个Validator只能被锁定在之前pre-commit块上</p>
<h5 id="Tendermint-BFT与PBFT的比较"><a href="#Tendermint-BFT与PBFT的比较" class="headerlink" title="Tendermint-BFT与PBFT的比较"></a>Tendermint-BFT与PBFT的比较</h5><h6 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h6><p>都属于BFT类型的算法，最多容忍不超过1&#x2F;3的恶意节点<br>都是三阶段提交，Tendermint的propose-&gt;pre-vote-&gt;pre-commit三个阶段，跟PBFT的三个阶段，pre-prepare, prepare, commit 三阶段是一一对应的<br>都在超时的时候，换掉proposer&#x2F;primary （都是leader）</p>
<h6 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h6><p>不过Tendermint相对于PBFT有两处简化。</p>
<p>Tendermint没有PBFT那种View Change阶段<br>Tendermint很巧妙的把超时的情况跟普通情况融合成了统一的形式，都是 propose-&gt;pre-vote-&gt;pre-commit 三阶段，只是超时的时候新块是一个特殊的空块。切换proposer是通过提交commit空块来触发的，而PBFT是有一个单独的view change过程来触发primary轮换。<br>Tendermint的所有信息都存储在区块链因为PBFT是1999年提出来的，那时候还没有blockchain这个东西(blockchain是2009年比特币出现之后才有的)，因此PBFT的所有节点虽有有一致的数据，但数据是分散存放的。<br>Tendermint和PBFT关系类似于Raft和Paxos的关系，Tendermint是PBFT的简化版，是针对blockchain这个场景下的简化版PBFT 。</p>
<h5 id="SHA256："><a href="#SHA256：" class="headerlink" title="SHA256："></a>SHA256：</h5><p>SHA256是SHA-2下细分出的算法（哈希函数）</p>
<p>对于任意长度的消息，SHA256会产生256bit长的哈希值叫消息摘要</p>
<h6 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h6><p>1.常量初始化</p>
<p>用到8个哈希初值以及64个哈希常量</p>
<p>这些8个初值是对自然数中前8个质数（2,3,5,7,11,13,17,19）的平方根的小数部分取前32bit而来，这些64个常量是对自然数中前64个质数(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…)的立方根的小数部分取前32bit而来。</p>
<p>2.信息预处理：</p>
<p>预处理指在想要Hash的消息后补充需要信息，使消息满足条件</p>
<p>预处理分：附加填充比特和附加长度</p>
<p>STEP1：附加填充比特</p>
<p>使报文长度对512取模后的余数为448</p>
<p>具体填充：先补第一个比特位1，然后都补0，知道达到要求。</p>
<p>信息是必须填充的，即使刚好满足条件，也要补512个比特</p>
<p>至于为什么是448？第二步会附上一个64bit的数据来表示原始报文长度。448+64&#x3D;512</p>
<p>STEP2：附加长度值</p>
<p>将原始数据长度信息补到STEP1后面</p>
<p>3.逻辑运算![img](file:&#x2F;&#x2F;&#x2F;C:\Users\the xie\AppData\Roaming\Tencent\Users\577037595\QQ\WinTemp\RichOle\L7Z(N{]]XQA)QL1AAHC}W$W.png)</p>
<p>∧按位“与”<br>¬按位“补”<br>⊕按位“异或”<br> S^{n}循环右移n个bit<br>R^{n}右移n个bit</p>
<p>4.计算消息摘要</p>
<p>将消息分解为512bit大小的块，假设可以分为n块，则需要做n次迭代，一个256bit摘要初始值为H0，经过第一个数据库进行运算，得到H1，H1再依次处理，得到Hn。256-bit的Hi被描述8个小块。第一次迭代中，H0映射初始值设为8个哈希初值</p>
<p>STEP1：构造64个字</p>
<p>对于每一块，分为16个字，记作w[0],···w[15]</p>
<p>其余的字由如下迭代公式得到：</p>
<p>![image-20230729171949754](C:\Users\the xie\AppData\Roaming\Typora\typora-user-images\image-20230729171949754.png)</p>
<p>STEP2：进行64次循环![img](file:&#x2F;&#x2F;&#x2F;C:\Users\the xie\AppData\Roaming\Tencent\Users\577037595\QQ\WinTemp\RichOle\5N07KYLOM[59D6_U%O1UF%I.png)![img](file:&#x2F;&#x2F;&#x2F;C:\Users\the xie\AppData\Roaming\Tencent\Users\577037595\QQ\WinTemp\RichOle\7SLSSQ]H4S5S&#96;&#96;13VQC3LDU.png)</p>
<p>![img](file:&#x2F;&#x2F;&#x2F;C:\Users\the xie\AppData\Roaming\Tencent\Users\577037595\QQ\WinTemp\RichOle\5N07KYLOM[59D6_U%O1UF%I.png)</p>
<h5 id="椭圆曲线数字签名算法"><a href="#椭圆曲线数字签名算法" class="headerlink" title="椭圆曲线数字签名算法"></a>椭圆曲线数字签名算法</h5><h6 id="签名："><a href="#签名：" class="headerlink" title="签名："></a>签名：</h6><p>简称ECC，是一种非对称加密算法。ECC的私钥本质为一个整数，其对应的公钥为椭圆曲线上的一点。</p>
<p>用私钥a对消息m签名，得到两个整数（r，s），过程如下：</p>
<p>1.随机生成临时私钥k，并计算其对于公钥K&#x3D;k*G&#x3D;（XK，YK）</p>
<p>2.计算r&#x3D;XK mod n，若r为0，则回到第一步</p>
<p>3.计算m的哈希e&#x3D;hash（m），并将e的二进制序列转成一个整数</p>
<p>4.计算s&#x3D;[（e+ra）&#x2F;k]mod n，若s为0，回到第一步</p>
<p>5得到签名（r，s）</p>
<p>若每次都用相同k，则知道e1，e2和签名（r1，s1），（r2，s2）时，有s1-s2&#x3D;[（e1-e2）mod n]&#x2F;k，这样可以得到k，从而反推a，所以每次签名时的k要绝对私密且足够随机</p>
<h6 id="验签："><a href="#验签：" class="headerlink" title="验签："></a>验签：</h6><p>公钥A和消息m验证签名（r，s），过程如下：<br>1.计算m的哈希e&#x3D;hash(m),将e的二进制序列转成整数</p>
<p>2.计算u1&#x3D;（e mod n）&#x2F;s</p>
<p>3.计算u2&#x3D; （r mod n）&#x2F;s</p>
<p>4.计算点P&#x3D;u1*G+u2 * A&#x3D;（Xp，Yp）</p>
<p>5.当r&#x3D;Xp mod n时，验签成功</p>
<h6 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h6><p>已知A&#x3D;aG，则</p>
<p>P&#x3D;u1*G+u2 *A&#x3D;（u1+u2a） *G&#x3D;（e&#x2F;s+ra&#x2F;s） *G</p>
<p>ps：忽略u1和u2的模n运算，没有问题，因为a*G&#x3D;（ a mod n） *G，详细查阅循环子群。</p>
<p>s&#x3D;[（e+ra）&#x2F;k]mod,同乘k再除以s，得：</p>
<p>k&#x3D;[（e+ra）&#x2F;s]mod n</p>
<p>也就是说，如果（r，s）正确，则验签时点P就是临时私钥k对于的公钥</p>
<p>P&#x3D;（e+ra）&#x2F;s*G&#x3D;k *G&#x3D;（Xp，Yp）</p>
<h5 id="Gossip："><a href="#Gossip：" class="headerlink" title="Gossip："></a>Gossip：</h5><p>由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点，它会随机选择周围几个节点散播消息，依次类推，直到网络中所有节点都收到消息。（最终一致性协议）</p>
<h5 id="实验指标："><a href="#实验指标：" class="headerlink" title="实验指标："></a>实验指标：</h5><p>参照组：全复制存储方案，基于编码的存储方案BFT-Store</p>
<h6 id="存储成本（单个区块存储所需的空间成本衡量）："><a href="#存储成本（单个区块存储所需的空间成本衡量）：" class="headerlink" title="存储成本（单个区块存储所需的空间成本衡量）："></a>存储成本（单个区块存储所需的空间成本衡量）：</h6><p>每个区块B（h）分割为r个一级分片，随后每个一级分片分割为k&#x3D;N-2F个二级分片，存储成本如下式子：<br>r * N * T&#x2F;k * r&#x3D;（约等于）3T</p>
<p>全复制存储方案存储成本为O（N * T），本方案降低至了O（T）。当系统节点数量增长时，存储花销保持在一个常数量级上。</p>
<h6 id="编解码效率（对编码和解码的吞吐量衡量）："><a href="#编解码效率（对编码和解码的吞吐量衡量）：" class="headerlink" title="编解码效率（对编码和解码的吞吐量衡量）："></a>编解码效率（对编码和解码的吞吐量衡量）：</h6><p>对于（N-2F，N）-RS编码方案</p>
<p>编码复杂度： ERS(N)&#x3D;O(N * (N-2F))</p>
<p>解码复杂度： DRS(N)&#x3D;O((N-2F)*(N-2F) *(N-2F))</p>
<p>对于解码，每个原始区块分割为r个一级分片，要恢复一个区块，需要进行r次解码</p>
<p>解码复杂度为：O（r*l * l * DRS（N））&#x3D;O（T&#x2F;(l *N) *l * l * N *N *N）&#x3D;O(T *l * N *N)</p>
<p>对于BFT-store方案将每N-2F个完整区块映射为N个编码块，解码复杂度为：</p>
<p>O（T * T *<em>DRS（N））&#x3D;O（T</em> * T*N *N *N）</p>
<p>两式子相比，得     ：T*N&#x2F;l&#x3D;2的18次方</p>
<p>解码效率提升了约2的18次方：<br>编码效率也以此类推：</p>
<p>O（T*T *ERS（N））&#x3D;O（T *T *N *N）</p>
<p>O（r* l *l *ERS（N））&#x3D;O（T *l *N）</p>
<h6 id="系统重初始化效率（节点平均完成重初始化流程所花时长衡量）："><a href="#系统重初始化效率（节点平均完成重初始化流程所花时长衡量）：" class="headerlink" title="系统重初始化效率（节点平均完成重初始化流程所花时长衡量）："></a>系统重初始化效率（节点平均完成重初始化流程所花时长衡量）：</h6><p>假设有新节点加入和有一现有节点退出，BFT-Store复杂度为O（N *T），本方案为O（T）</p>
<p>查找的相关文献：</p>
<p>1.A Scalable Multi-Layer PBFT Consensus for Blockchain</p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9279277">https://ieeexplore.ieee.org/document/9279277</a></p>
<p>PBFT的瓶颈在于依赖大量节点间的通信，基于PBFT的区块链很难拓展到100个节点，因此出现了短期签名的PBFT和分片。这种权衡包括增加通信成本和降低安全级别。本文提出了可以限制层或子组内的通信来构建分层的多层PBFT，按组进行次共识，总体共识可以定义为超过达成次共识的组的数量</p>
<p>![image-20230730111223340](C:\Users\the xie\AppData\Roaming\Typora\typora-user-images\image-20230730111223340.png)</p>
<p>如图，存在m个一层replicas，一个replicas下面又有n个sub-layer replicas，网络节点总数为1+m+mn，此共识算法最多能容纳[n&#x2F;3] *[m&#x2F;2]个故障节点，同时仅m平方+m *n方个节点通信，而不是O（Z方）这样的传统单层PBFT。由于共识达成过程不止经过一层，所以提高可扩展性的代价为更长的延迟。</p>
<p>2.A Reliable Storage Partition for Permissioned Blockchain</p>
<p><a target="_blank" rel="noopener" href="http://ieeexplore-ieee-org-s.vpn.uestc.edu.cn:8118/stamp/stamp.jsp?tp=&arnumber=9152150">http://ieeexplore-ieee-org-s.vpn.uestc.edu.cn:8118/stamp/stamp.jsp?tp=&amp;arnumber=9152150</a></p>
<h4 id="第四章-基于分组编码的联盟链存储方案"><a href="#第四章-基于分组编码的联盟链存储方案" class="headerlink" title="第四章 基于分组编码的联盟链存储方案"></a>第四章 基于分组编码的联盟链存储方案</h4><h5 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h5><p>先将单个区块进行数据分片，根据 PBFT 协议的容错性能确定合适的 RS 编码方案进行编 码，最后通过 PBFT 协议对编码值进行共识。上述过程由选举出的本视图分组 （Committee）执行</p>
<p>本方案的解码工作在一个由 n 个节点组成的分组内进 行，由主节点（也在分组内）向组内多播 decode 消息，当收到足够来自不同组内 节点的有效编码值集合 Fh(s) 后，进行解码。</p>
<p>在 BFT-Store 方案和 PartitionChain 方案中，解码过程由主节点全网广播 decode 消息，所有诚实节点都必须参与到解码过程中，相较于全复制存储方案，带 来了额外的网络通信量。本方案的解码工作在一个由 n 个节点组成的分组内进 行，由主节点（也在分组内）向组内多播 decode 消息，当收到足够来自不同组内 节点的有效编码值集合 Fh(s) 后，进行解码。</p>
<h5 id="编码与共识"><a href="#编码与共识" class="headerlink" title="编码与共识"></a>编码与共识</h5><p>具体的流程如图 4.1和算法 5所示，对于一个新区块 B(h)，首先由主节点负责 在组内进行数据分片、编码与签名验证，随后将签名集合 H 与 commit 消息一起 在组内多播（行 2-7，行 13）。当组内从节点 Ms 收到 F +1 个有效的签名集合后，将 其中对于自己所对应的编码值进行两次聚合，得到最终的聚合签名 σh,s（行 8-11）； 而主节点收到 F + 1 个有效的签名集合后，需要对全网范围内所有节点（除组内 成员外）的数字签名进行聚合，并通过 inform 消息 &lt; INF ORM, v, h, t, Ft , σh,t &gt; 将编码值 Ft 与聚合签名 σh,t 发送给对应节点 Nt，其中 v 为当前视图编号（行 14-18）。当共识完成且全网节点存储了对应的编码值与签名后，组内节点可丢弃 多余的编码值与信息。</p>
<h5 id="解码与数据恢复"><a href="#解码与数据恢复" class="headerlink" title="解码与数据恢复"></a>解码与数据恢复</h5><p>当主节点收到来自客户端的请求时，将在当前视图分组内多播一个 decode 消息 &lt; DECODE, v, h, N, f + 1 &gt;，成员 Ms 收到来自主节点的 decode 消息后， 将本地存储的编码值集合 Fh(s) 以及数字签名 σh,s 发送给主节点。当主节点收到 了 f + 1 个来自不同从节点的验证通过的编码值集合后，证明此时分组未被拜占 庭敌手控制，解码可正常进行。主节点通过解码，可得到每个一级分片 Bi(h) 对 应的二级分片集合：{bi,1(h), …, bi,k(h)}，将所有恢复得到的二级分片： b1,1(h), …, b1,k(h), …, br,1(h), …, br,k(h) 根据它们的索引 i 和 j 进行链接，即可得到原始区块 B(h)。如果计时算法超时或 这节点无法计算得到正确的结果，则可由组内成员发起 CE 流程更换当前视图并 重新选举分组。</p>
<h5 id="视图更换与分组选举"><a href="#视图更换与分组选举" class="headerlink" title="视图更换与分组选举"></a>视图更换与分组选举</h5><p>在本方案中，存在主节点L，可能是拜占庭节点的可能，此时主节点可能完全不作响应或发送不同的消息给从节点，导致协议无法正常推进。为了检测上述情况，本方案设定一个计时器TIME，如果超过此时间上限4△，分组还未对某高度H内的区块达成共识或正确执行客户端的请求，则会触发视图更换流程，假设当前视图编号为v,则新视图编号为v＋1。具体的流程如图4.3所示，主要包括四个阶段:Viewchange阶段、Election阶段、Ready阶段和Newveiw阶段</p>
<p>Viewchange阶段：成员检测到超时，向组内多播viewchange消息</p>
<p>Election阶段：收到超过f+1个通过验证的viewchange消息后，向全网广播election消息。当节点收到消息后进行验证，通过后节点将通过哈希算法计算出拥有参与选举资格的节点。</p>
<p>Ready阶段：在以上节点选择哈希值最小的节点作为主节点。分组成员向主节点发送ready消息，启动time计时器，若超过2Δ仍未收到新节点的newview消息，则在组内多播viewchange消息，发起新的视图轮换。</p>
<p>Newview阶段：收到2f+1个ready消息后，主节点向全网广播newview消息，更换视图。</p>
<h5 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h5><h6 id="存储成本："><a href="#存储成本：" class="headerlink" title="存储成本："></a>存储成本：</h6><p>对照的两种方案为（N-2F，N）-RS编码，本方案采用（f+1，N）-RS编码，本方案存储花销略高于其他两种</p>
<h6 id="系统吞吐量："><a href="#系统吞吐量：" class="headerlink" title="系统吞吐量："></a>系统吞吐量：</h6><p>本方案最高，PartitionChain方案其次，BFT-Store方案最低。节点数量增加对于三种方案的系统吞吐量影响较小。同时，对于此方案，分组节点数少的系统吞吐量相对较高。</p>
<h6 id="系统平均时延"><a href="#系统平均时延" class="headerlink" title="系统平均时延:"></a>系统平均时延:</h6><p>本方案最低，PartitionChain方案其次，BFT-Store方案最高</p>
<h5 id="论文更新"><a href="#论文更新" class="headerlink" title="论文更新"></a>论文更新</h5><p>LBFT: An Asynchronous Committee-Based Blockchain Storage<br>Strategy on Zero Trust Model</p>
<p>解决如何将此方法运用在零信任模型上面</p>
<p>我们的目标是设计一种基于更高级别安全模型（称为零信任模型）的存储策略。它没有关注传统信任模型中的外围防御，而是将所有网络流量标记为不可信，并需要严格验证，无论数据包是从内部网络还是外部网络传输的。此外，我们采用了无证书聚合签名（CLAS）方案，消除了对TTP生成、存储和更新节点密钥的依赖。我们将节点放置在不同的委员会中，并在每个委员会内同时运行内部共识协议，提出了一种可行的解决方案，其中只有一部分节点参与数据访问的每一轮解码。它结合了Reed–Solomon（RS）编码和HoneyBadger BFT（HBBFT）协议</p>
<p>零信任模型的不可或缺的要求：（1）无论网络的拓扑位置如何，所有网络流量都需要加密；（2） 对系统资源的访问是在每个连接的基础上动态授权的，它不会自动允许访问另一个不同的资源</p>
<p>HoneyBadger BFT和Dumbo可以在异步网络中实现共识</p>
<p>VSSB-Rat:A Secure and Eficient Zero Trust Consensus Algorithm for<br>Blockchain</p>
<p>我们将零信任与Raft一致性算法相结合，提出了一种安全可靠的一致性算法——可验证秘密共享拜占庭容错Raft共识性算法（VSSB Raft）。VSSB Raft共识算法通过监督节点和秘密共享算法实现了零信任，而不需要算法所要求的节点之间的不可见信任。VSSB Raft一致性算法使用SM2签名算法来实现数据使用前需要验证的零信任特性。此外，通过引入NDN网络，我们重新设计了节点之间的通信，并保证了节点间的通信质量。本文提出的VSSB-Raft一致性算法可以通过设置秘密共享阈值使算法具有拜占庭容错性，同时保持算法的复杂度为O（n）VSSB Raft共识算法由两部分组成：1）安全的领导者节点选举方法和2）客户端消息传输方法。</p>
<p>作者认为额外增加的安全认证机制会影响区块链的安全性</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Zhen Xie</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2023/09/12/%E5%8C%BA%E5%9D%97%E9%93%BE/">http://example.com/2023/09/12/%E5%8C%BA%E5%9D%97%E9%93%BE/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"># 区块链</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Zhen Xie | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>