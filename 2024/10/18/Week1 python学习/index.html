<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Zhen Xie">





<title>Week1 python学习 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>
<script>
    !
    function() {
    function n(n, e, t) {
    return n.getAttribute(e) || t
    }
    function e(n) {
    return document.getElementsByTagName(n)
    }
    function t() {
    var t = e("script"),
    o = t.length,
    i = t[o - 1];
    return {
    l: o,
    z: n(i, "zIndex", -1), //置于主页面背后
    o: n(i, "opacity", .5), //线条透明度
    c: n(i, "color", "0,0,0"), //线条颜色
    n: n(i, "count", 100) //线条数量
    }
    }
    function o() {
    a = m.width = window.innerWidth ||
    document.documentElement.clientWidth || document.body.clientWidth,
    c = m.height = window.innerHeight ||
    document.documentElement.clientHeight || document.body.clientHeight
    }
    function i() {
    r.clearRect(0, 0, a, c);
    var n, e, t, o, m, l;
    s.forEach(function(i, x) {
    for (i.x += i.xa, i.y += i.ya, i.xa *= i.x > a || i.x < 0 ? -1 :
    1, i.ya *= i.y > c || i.y < 0 ? -1 : 1, r.fillRect(i.x - .5, i.y - .5, 1,
    1), e = x + 1; e < u.length; e++) n = u[e],
    null !== n.x && null !== n.y && (o = i.x - n.x, m = i.y - n.y, l
    = o * o + m * m, l < n.max && (n === y && l >= n.max / 2 && (i.x -= .03 * o,
    i.y -= .03 * m), t = (n.max - l) / n.max, r.beginPath(), r.lineWidth = t /
    2, r.strokeStyle = "rgba(" + d.c + "," + (t + .2) + ")", r.moveTo(i.x, i.y),
    r.lineTo(n.x, n.y), r.stroke()))
    }),
    x(i)
    }
    var a, c, u, m = document.createElement("canvas"),
    d = t(),
    l = "c_n" + d.l,
    r = m.getContext("2d"),
    x = window.requestAnimationFrame || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(n) {
    window.setTimeout(n, 1e3 / 45)
    },
    w = Math.random,
    y = {
    x: null,
    y: null,
    max: 2e4
    };
    m.id = l,
    m.style.cssText = "position:fixed;top:0;left:0;z-index:" + d.z +
    ";opacity:" + d.o,
    e("body")[0].appendChild(m),
    o(),
    window.onresize = o,
    window.onmousemove = function(n) {
    n = n || window.event,
    y.x = n.clientX,
    y.y = n.clientY
    },
    window.onmouseout = function() {
    y.x = null,
    y.y = null
    };
    for (var s = [], f = 0; d.n > f; f++) {
    var h = w() * a,
    g = w() * c,
    v = 2 * w() - 1,
    p = 2 * w() - 1;
    s.push({
    x: h,
    y: g,
    xa: v,
    ya: p,
    max: 6e3
    })
    }
    u = s.concat([y]),
    setTimeout(function() {
    i()
    },
    100)
    } ();
    </script>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">TheXie&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">TheXie&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Week1 python学习</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Zhen Xie</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">October 18, 2024&nbsp;&nbsp;15:02:25</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/language/">language</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="Week1-python学习"><a href="#Week1-python学习" class="headerlink" title="Week1 python学习"></a>Week1 python学习</h2><h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><h5 id="1-Number数字（支持int，float-complex）"><a href="#1-Number数字（支持int，float-complex）" class="headerlink" title="1.Number数字（支持int，float, complex）"></a>1.Number数字（支持int，float, complex）</h5><h5 id="2-String字符串"><a href="#2-String字符串" class="headerlink" title="2.String字符串"></a>2.String字符串</h5><p>字符串连接</p>
<p>1）使用+运算符</p>
<p>2）使用join运算符 </p>
<p>new_str&#x3D; ‘-‘.join(‘Hello’) # H-e-l-l-o-w</p>
<h5 id="3-List列表（负数也可以表示位置，-1-为从末尾的开始位置；中括号表示）"><a href="#3-List列表（负数也可以表示位置，-1-为从末尾的开始位置；中括号表示）" class="headerlink" title="3.List列表（负数也可以表示位置，-1 为从末尾的开始位置；中括号表示）"></a>3.List列表（负数也可以表示位置，-1 为从末尾的开始位置；中括号表示）</h5><p>1）添加列表元素</p>
<p>girls.append（’b’），末尾追加</p>
<p>2）列表合并，把一个列表添加到另一个列表</p>
<p>models&#x3D;[‘a’,’c’]</p>
<p>girls.extend（models），一次添加多个</p>
<p>3）指定位置添加</p>
<p>girls.insert(1,’s’)</p>
<p>4）列表元素修改需找到<strong>下标</strong></p>
<p>eg：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fruits = [&#x27;apple&#x27;,&#x27;pear&#x27;,&#x27;香蕉&#x27;,&#x27;pineapple&#x27;,&#x27;草莓&#x27;]</span><br><span class="line">for fruit in fruits:</span><br><span class="line">    if &#x27;香蕉&#x27; in fruit:</span><br><span class="line">        fruit = &#x27;banana&#x27;</span><br><span class="line">print(fruits)</span><br><span class="line">#[&#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;香蕉&#x27;, &#x27;pineapple&#x27;, &#x27;strawberry&#x27;]</span><br><span class="line">for i in range(len(fruits)):</span><br><span class="line">    if &#x27;香蕉&#x27; in fruits[i]:</span><br><span class="line">        fruits[i] = &#x27;banana&#x27;</span><br><span class="line">        break</span><br><span class="line">print(fruits)</span><br><span class="line">#[&#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;banana&#x27;, &#x27;pineapple&#x27;, &#x27;strawberry&#x27;]</span><br></pre></td></tr></table></figure>

<p>5）列表元素删除</p>
<p>del words[1]</p>
<p>words.remove(‘cat’)  </p>
<p>words.pop(1)</p>
<p>6）列表切片（左开右闭）</p>
<p>print（animals[-5: -1 :2]）#取-5，-3</p>
<p>print（animals[:  :-1]）#从后往前取</p>
<h5 id="4-Tuple元组（tuple与list类似，不同之处在于tuple的元素不能修改。tuple写在小括号里，元素之间用逗号隔开。元组的元素不可变，但可以包含可变对象，如list。；小括号表示）"><a href="#4-Tuple元组（tuple与list类似，不同之处在于tuple的元素不能修改。tuple写在小括号里，元素之间用逗号隔开。元组的元素不可变，但可以包含可变对象，如list。；小括号表示）" class="headerlink" title="4.Tuple元组（tuple与list类似，不同之处在于tuple的元素不能修改。tuple写在小括号里，元素之间用逗号隔开。元组的元素不可变，但可以包含可变对象，如list。；小括号表示）"></a>4.Tuple元组（tuple与list类似，不同之处在于tuple的元素不能修改。tuple写在小括号里，元素之间用逗号隔开。元组的元素不可变，但可以包含可变对象，如list。；小括号表示）</h5><p>1）一个元素时，需要在后面加逗号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tuple2 = (&#x27;hello&#x27;)</span><br><span class="line">print(type(tuple2))</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line">tuple3 = (&#x27;hello&#x27;,)</span><br><span class="line">print(type(tuple3))</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>2）tuple.count(4)统计元组中4的个数</p>
<p>3）tuple.index(4)元组中4所对应的下标</p>
<p>4）装包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t4 = (1,2,3,4,5)</span><br><span class="line"></span><br><span class="line">#将t4[0],t4[1]分别赋值给a,b;其余的元素装包后赋值给c</span><br><span class="line">a,b,*c = t4</span><br><span class="line">print(a,b,c) #1 2 [3, 4, 5]</span><br><span class="line">print(c)#[3, 4, 5]</span><br><span class="line">print(*c)#3 4 5</span><br></pre></td></tr></table></figure>

<h5 id="5-dict字典（键值对存储，键必须是不可变类型，且必须唯一）"><a href="#5-dict字典（键值对存储，键必须是不可变类型，且必须唯一）" class="headerlink" title="5.dict字典（键值对存储，键必须是不可变类型，且必须唯一）"></a>5.dict字典（键值对存储，键必须是不可变类型，且必须唯一）</h5><p>1)函数items()（键值对) keys()（键） values()（值）</p>
<p>2）get()获取值</p>
<p>dict5.get（‘xz’）</p>
<p>dict5.get（‘xz’，170） #如果能取到值，则返回字典中的值，否则返回默认值170</p>
<p>3）元组删除</p>
<p>del dict6(‘xz’)</p>
<p>dict6.pop(‘xz’)</p>
<h5 id="6-set集合（也是一组key的集合（数学意义上的集合，可以进行交集、并集、差集等操作），会过滤重复元素）"><a href="#6-set集合（也是一组key的集合（数学意义上的集合，可以进行交集、并集、差集等操作），会过滤重复元素）" class="headerlink" title="6.set集合（也是一组key的集合（数学意义上的集合，可以进行交集、并集、差集等操作），会过滤重复元素）"></a>6.set集合（也是一组key的<strong>集合</strong>（数学意义上的集合，可以进行交集、并集、差集等操作），会过滤重复元素）</h5><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>定义一个类：</p>
<p>init（）定义构造函数，python中会明确把代表自身实例的self作为第一个参数，相当于java中的this（注意init 的写法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person:        </span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">        print (&#x27;调用父类构造函数&#x27;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&#x27;调用父类方法&#x27;)</span><br><span class="line"> </span><br><span class="line">class Student(Person):  # 定义子类</span><br><span class="line">   def __init__(self):</span><br><span class="line">      print (&#x27;调用子类构造方法&#x27;)</span><br><span class="line"> </span><br><span class="line">   def study(self):</span><br><span class="line">      print(&#x27;调用子类方法&#x27;)</span><br><span class="line"></span><br><span class="line">s = Student()          # 实例化子类</span><br><span class="line">s.study()              # 调用子类的方法</span><br><span class="line">s.eat()                # 调用父类方法</span><br></pre></td></tr></table></figure>

<h4 id="JSON格式："><a href="#JSON格式：" class="headerlink" title="JSON格式："></a>JSON格式：</h4><p>1.json.dumps用于将Python对象编码成JSON字符串。</p>
<p>json &#x3D;json.dumps(data)</p>
<p>为了提高可读性，提供了一些可选参数（sort_keys&#x3D;True,按字典排序输出，indent参数，代表缩减位数，separators参数去掉，和：后面的空格）</p>
<p>json &#x3D; json.dumps(data, sort_keys&#x3D;True, indent&#x3D;4,separators&#x3D;(‘,’, ‘:’))</p>
<p>2.json.loads用于解码JSON数据</p>
<h4 id="异常处理："><a href="#异常处理：" class="headerlink" title="异常处理："></a>异常处理：</h4><p>try&#x2F;except捕捉异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    fh = open(&quot;/home/aistudio1/data/testfile01.txt&quot;, &quot;w&quot;)</span><br><span class="line">    fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)</span><br><span class="line">except IOError:</span><br><span class="line">    print(&#x27;Error: 没有找到文件或读取文件失败&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print (&#x27;内容写入文件成功&#x27;)</span><br><span class="line">    fh.close()</span><br></pre></td></tr></table></figure>

<p>finally中的内容，退出try时总会执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    f = open(&quot;/home/aistudio/data/testfile02.txt&quot;, &quot;w&quot;)</span><br><span class="line">    f.write(&quot;这是一个测试文件，用于测试异常!!&quot;)</span><br><span class="line">finally:</span><br><span class="line">    print(&#x27;关闭文件&#x27;)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>三引号：不在考虑引号、特殊字符串和转义符号这些，所见即所得。</p>
<h4 id="Numpy-N维数组对象和向量运算"><a href="#Numpy-N维数组对象和向量运算" class="headerlink" title="Numpy:N维数组对象和向量运算"></a>Numpy:N维数组对象和向量运算</h4><p>numpy中文网：<a target="_blank" rel="noopener" href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></p>
<h5 id="1-数组（矩阵）创建"><a href="#1-数组（矩阵）创建" class="headerlink" title="1.数组（矩阵）创建"></a>1.数组（矩阵）创建</h5><p>1)使用array函数可以通过列表或元组创建数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">#将列表转换为数组</span><br><span class="line">array = np.array([[1,2,3],</span><br><span class="line">                 [4,5,6]])</span><br><span class="line">#将元组转换为数组</span><br><span class="line">array = np.array(((1,2,3),</span><br><span class="line">                 (4,5,6))</span><br><span class="line">print(array)</span><br><span class="line">#[[1 2 3]</span><br><span class="line">  [4 5 6]]</span><br></pre></td></tr></table></figure>

<p>2)创建具有初始占位符内容的数组。</p>
<p>zeros（）：创建指定长度或者形状的全0数组</p>
<p>ones（）：创建指定长度或者形状的全1数组</p>
<p>empty（）：创建一个数组，初始内容随机，取决于内存的状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zeroarray = np.zeros((2,3))</span><br><span class="line">print(zeroarray)</span><br><span class="line">onearray = np.ones((3,4),dtype=&#x27;int64&#x27;)</span><br><span class="line">print(onearray)</span><br><span class="line">emptyarray = np.empty((3,4))</span><br><span class="line">print(emptyarray)</span><br></pre></td></tr></table></figure>

<h5 id="2-其他方法："><a href="#2-其他方法：" class="headerlink" title="2.其他方法："></a>2.其他方法：</h5><p>arrange函数：类似range函数，返回数组而不是列表</p>
<p>ndim函数：输出数组维度</p>
<p>shape函数：输出数组形状（行列值）</p>
<p>size函数：输出数组元素个数</p>
<p>dtype函数：输出数组元素类型</p>
<p>reshape函数：重新定义数字形状</p>
<p>array1 &#x3D; np.arange(6).reshape([2,3]) </p>
<h5 id="3-数组计算（内部元素计算）：（不用循环即可对数据进行批量运算，叫矢量化，大小相等的数组之间的任何算术运算都会将运算应用到元素级）"><a href="#3-数组计算（内部元素计算）：（不用循环即可对数据进行批量运算，叫矢量化，大小相等的数组之间的任何算术运算都会将运算应用到元素级）" class="headerlink" title="3.数组计算（内部元素计算）：（不用循环即可对数据进行批量运算，叫矢量化，大小相等的数组之间的任何算术运算都会将运算应用到元素级）"></a>3.数组计算（内部元素计算）：（不用循环即可对数据进行批量运算，叫矢量化，大小相等的数组之间的任何算术运算都会将运算应用到元素级）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([[1,2,3],[4,5,6]])</span><br><span class="line">arr2 = np.ones([2,3],dtype=np.int64)</span><br><span class="line"></span><br><span class="line">print(arr1 + arr2)</span><br><span class="line">print(arr1 - arr2)</span><br><span class="line">print(arr1 * arr2)</span><br><span class="line">print(arr1 / arr2)</span><br><span class="line">print(arr1 ** 2)</span><br></pre></td></tr></table></figure>

<h5 id="4-矩阵乘法：dot"><a href="#4-矩阵乘法：dot" class="headerlink" title="4.矩阵乘法：dot"></a>4.矩阵乘法：dot</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr3 = np.array([[1,2,3],[4,5,6]])</span><br><span class="line">arr4 = np.ones([3,2],dtype=np.int64)</span><br><span class="line">print(arr3)</span><br><span class="line">print(arr4)</span><br><span class="line">print(np.dot(arr3,arr4))</span><br></pre></td></tr></table></figure>

<h5 id="5-矩阵其他计算："><a href="#5-矩阵其他计算：" class="headerlink" title="5.矩阵其他计算："></a>5.矩阵其他计算：</h5><p>每一行（列）求和：np.sum(arr3,axis&#x3D;1)#axis&#x3D;1,每一行求和  axis&#x3D;0，每一列求和</p>
<p>矩阵中最大值：np.max(arr3)</p>
<p>矩阵中最小值：np.min(arr3)</p>
<p>均值：np.mean(arr3)</p>
<p>矩阵中最大值下标：np.argmax(arr3)</p>
<p>矩阵中最小值下标：np.argmin(arr3)</p>
<p>矩阵转置：arr3.transpose()</p>
<p>矩阵拍平（多维变一维）：arr3.flatten()（拍平过后数据类型还是数组，不是list类型）</p>
<h5 id="6-索引与切片："><a href="#6-索引与切片：" class="headerlink" title="6.索引与切片："></a>6.索引与切片：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr5 = np.arange(0,6).reshape([2,3])</span><br><span class="line">print(arr5)   </span><br><span class="line">#[[0 1 2]</span><br><span class="line"> [3 4 5]]</span><br><span class="line">print(arr5[1]) #[3 4 5]</span><br><span class="line">print(arr5[1][2]) # 5 </span><br><span class="line">print(arr5[1,2]) # 5</span><br><span class="line">print(arr5[1,:]) #[3 4 5]</span><br><span class="line">print(arr5[:,1]) # [1 4]</span><br><span class="line">print(arr5[1,0:2]) # [3 4]</span><br></pre></td></tr></table></figure>

<h4 id="Pandas：高效数据分析处理库"><a href="#Pandas：高效数据分析处理库" class="headerlink" title="Pandas：高效数据分析处理库"></a>Pandas：高效数据分析处理库</h4><p>中文网站：<a target="_blank" rel="noopener" href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></p>
<p>核心数据结构：</p>
<h5 id="1-Series（类似键值对，但键可以重复）"><a href="#1-Series（类似键值对，但键可以重复）" class="headerlink" title="1.Series（类似键值对，但键可以重复）"></a>1.Series（类似键值对，但键可以重复）</h5><p>1）实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;],index=[100,200,100,400,500])</span><br><span class="line">print(s) #打印出来的dtype为object类型而不是string类型，因为pandas默认使用object类来存储字符串，可以使用s = pd.Series([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], dtype=&quot;string&quot;)来显示声明</span><br><span class="line"></span><br><span class="line">#用字典实例化</span><br><span class="line">d = &#123;&#x27;b&#x27;: 1, &#x27;a&#x27;: 0, &#x27;c&#x27;: 2&#125;</span><br><span class="line">pd.Series(d)</span><br><span class="line"></span><br><span class="line">#读json实例化</span><br><span class="line">df = pd.read_json(&#x27;data/data31557/20200422.json&#x27;)</span><br></pre></td></tr></table></figure>

<p>2）获取values和index属性</p>
<p>s.values</p>
<p>s.index</p>
<p>3）取值（通过索引选取单个或一组值）</p>
<p>s[100]</p>
<p>s[400,500]</p>
<p>4)对应元素求和，相乘</p>
<p>print(s+s)</p>
<p>print(s*3)</p>
<p>5）分类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_json(&#x27;data/data31557/20200422.json&#x27;)</span><br><span class="line">#print(df)</span><br><span class="line"></span><br><span class="line">grouped=df[&#x27;name&#x27;].groupby(df[&#x27;zone&#x27;])</span><br><span class="line">s = grouped.count()</span><br></pre></td></tr></table></figure>

<p>6）分段</p>
<p>#cut用来把一组数据分割成离散 的区间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin=[0,45,50,55,100]</span><br><span class="line">se1=pd.cut(arrs,bin)</span><br><span class="line">pd.value_counts(se1)</span><br></pre></td></tr></table></figure>

<p>它会在算术运算中<strong>自动对齐不同索引的数据</strong></p>
<p>Series 和多维数组的主要区别在于， Series 之间的操作会自动基于标签对齐数据。因此，不用顾及执行计算操作的 Series 是否有相同的标签。类似于数组合并</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj1 = pd.Series(&#123;&quot;Ohio&quot;: 35000, &quot;Oregon&quot;: 16000, &quot;Texas&quot;: 71000, &quot;Utah&quot;: 5000&#125;)</span><br><span class="line">print(obj1)</span><br><span class="line">obj2 = pd.Series(&#123;&quot;California&quot;: np.nan, &quot;Ohio&quot;: 35000, &quot;Oregon&quot;: 16000, &quot;Texas&quot;: 71000&#125;)</span><br><span class="line">print(obj2)</span><br><span class="line">print(obj1 + obj2)</span><br></pre></td></tr></table></figure>

<p>4）切片</p>
<p>print(s[1:])</p>
<p>print(s[:-1])</p>
<p>print(s[1:]+s[:-1])</p>
<h5 id="2-DataFrame（类似excel表或sql，可以行索引，列索引）"><a href="#2-DataFrame（类似excel表或sql，可以行索引，列索引）" class="headerlink" title="2.DataFrame（类似excel表或sql，可以行索引，列索引）"></a>2.DataFrame（类似excel表或sql，可以行索引，列索引）</h5><p>1）实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#用多维数组字典、列表字典生成DataFrame</span><br><span class="line">data = &#123;&#x27;state&#x27;: [&#x27;Ohio&#x27;, &#x27;Ohio&#x27;, &#x27;Ohio&#x27;, &#x27;Nevada&#x27;, &#x27;Nevada&#x27;], &#x27;year&#x27;: [2000, 2001, 2002, 2001, 2002], &#x27;pop&#x27;: [1.5, 1.7, 3.6, 2.4, 2.9]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br><span class="line">print(frame)</span><br><span class="line">#也可以指定列顺序，index，如果传入列在数据中找不到，会产生NAN</span><br><span class="line">frame2 = pd.DataFrame(data, columns=[&#x27;year&#x27;, &#x27;state&#x27;, &#x27;pop&#x27;, &#x27;debt&#x27;], index=[&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;])</span><br><span class="line">print(frame2)</span><br><span class="line"></span><br><span class="line">#用Series字典生成DataFrame</span><br><span class="line">d = &#123;&#x27;one&#x27;: pd.Series([1., 2., 3.], index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]),</span><br><span class="line">     &#x27;two&#x27;: pd.Series([1., 2., 3., 4.], index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])&#125;</span><br><span class="line">print(pd.DataFrame(d))</span><br></pre></td></tr></table></figure>

<p>2）列索引（将DataFrame的列获取为一个Series）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print（frame2[&#x27;state&#x27;]）#查找</span><br><span class="line">frame2[&#x27;debt&#x27;]=16.5#修改</span><br><span class="line">frame2[&#x27;new&#x27;] = frame2[&#x27;debt&#x27; ]* frame2[&#x27;pop&#x27;] #修改</span><br><span class="line">frame2[&#x27;debt&#x27;] = np.arange(5.) #修改</span><br></pre></td></tr></table></figure>



<h4 id="Matplotlib：绘制二维图形的Python库，用于绘图、可视化"><a href="#Matplotlib：绘制二维图形的Python库，用于绘图、可视化" class="headerlink" title="Matplotlib：绘制二维图形的Python库，用于绘图、可视化"></a>Matplotlib：绘制二维图形的Python库，用于绘图、可视化</h4><p>中文网站：<a target="_blank" rel="noopener" href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn</a></p>
<h5 id="1-生成一条直线"><a href="#1-生成一条直线" class="headerlink" title="1.生成一条直线"></a>1.生成一条直线</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np </span><br><span class="line"></span><br><span class="line">x = np.linspace(-1,1,50) #等差数列</span><br><span class="line">y = 2*x + 1</span><br><span class="line"></span><br><span class="line">#传入x,y,通过plot()绘制出折线图 </span><br><span class="line">plt.plot(x,y)</span><br><span class="line"></span><br><span class="line">#显示图形</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h5 id="2-生成多条线段"><a href="#2-生成多条线段" class="headerlink" title="2.生成多条线段"></a>2.生成多条线段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(7,5))</span><br><span class="line">l1, = plt.plot(x,y1,color=&#x27;red&#x27;,linewidth=1)</span><br><span class="line">l2, = plt.plot(x,y2,color=&#x27;blue&#x27;,linewidth=5)</span><br><span class="line">plt.legend(handles=[l1,l2],labels=[&#x27;aa&#x27;,&#x27;bb&#x27;],loc=&#x27;best&#x27;)#图例</span><br><span class="line">plt.xlabel(&#x27;x&#x27;,fontsize=20)#横坐标标签</span><br><span class="line">plt.ylabel(&#x27;y&#x27;,fontsize=20)#纵坐标标签</span><br><span class="line">plt.xlim((0,1))  #x轴只截取一段0到1进行显示</span><br><span class="line">plt.ylim((0,1))  #y轴只截取一段进行显示</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h5 id="3-生成散点图"><a href="#3-生成散点图" class="headerlink" title="3.生成散点图"></a>3.生成散点图</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dots1 =np.random.rand(50)#横坐标</span><br><span class="line">dots2 =np.random.rand(50)#纵坐标</span><br><span class="line">plt.scatter(dots1,dots2,c=&#x27;red&#x27;,alpha=0.5) #c表示颜色，alpha表示透明度</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h5 id="4-生成柱状图"><a href="#4-生成柱状图" class="headerlink" title="4.生成柱状图"></a>4.生成柱状图</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(10)</span><br><span class="line">y = 2**x+10</span><br><span class="line">plt.bar(x,y,facecolor=&#x27;#9999ff&#x27;,edgecolor=&#x27;white&#x27;)#facecolor柱的颜色，edgecolor背景颜色</span><br><span class="line">for ax,ay in zip(x,y):</span><br><span class="line">    plt.text(ax,ay,&#x27;%.1f&#x27; % ay,ha=&#x27;center&#x27;,va=&#x27;bottom&#x27;)#水平对齐为居中，垂直对齐为底部对齐，文本会放置在柱子顶部的正上方</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h5 id="5-生成饼图"><a href="#5-生成饼图" class="headerlink" title="5.生成饼图"></a>5.生成饼图</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sizes =[size1,size2,size3,size4]</span><br><span class="line">labels=&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;</span><br><span class="line">explode = (0.2,0.1,0,0)#离中心距离</span><br><span class="line">fig1，ax1 =plt.subplots #fig1为画布，ax1为饼图</span><br><span class="line">ax1.pie（sizes，explode=explode，labels=labels，autopct=&#x27;%1.1f%%&#x27;，shadow=True）</span><br><span class="line">ax1.axis(&#x27;equal&#x27;)#保证生成的是个圆，不然可能是椭圆</span><br></pre></td></tr></table></figure>

<p>1）显示中文</p>
<p><em># 设置显示中文</em> </p>
<p>plt.rcParams[‘font.sans-serif’] &#x3D; [‘SimHei’] <em># 指定默认字体</em></p>
<p>2）调节坐标倾斜度，字体大小</p>
<p><em># 这里是调节横坐标的倾斜度，rotation是度数，以及设置刻度字体大小</em> plt.xticks(rotation&#x3D;45,fontsize&#x3D;20) plt.yticks(fontsize&#x3D;20)</p>
<p>3）设置题目</p>
<p>plt.title(‘’’《青春有你2》参赛选手’’’,fontsize &#x3D; 24)</p>
<h4 id="PIL：强大图像处理能力的第三方库（与Matplotlib混用）"><a href="#PIL：强大图像处理能力的第三方库（与Matplotlib混用）" class="headerlink" title="PIL：强大图像处理能力的第三方库（与Matplotlib混用）"></a>PIL：强大图像处理能力的第三方库（与Matplotlib混用）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">#只导入 PIL 中的 Image 类，相比import PIL导入整个 PIL 库，调用时需要使用完整路径，如 PIL.Image.open()，相对冗长。</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">#读取图片</span><br><span class="line">img = Image.open(&#x27;C:/Users/the xie/PycharmProjects/pythonProject1/demo/xz.jpg&#x27;)</span><br><span class="line"></span><br><span class="line">img.show() #自动调用计算机上显示图片的工具</span><br><span class="line"></span><br><span class="line">plt.imshow(img) #加载图像</span><br><span class="line">plt.show() #在Plots中显示图像</span><br><span class="line"></span><br><span class="line">#获得图像的模式</span><br><span class="line">img_mode = img.mode</span><br><span class="line">print(img_mode)</span><br><span class="line">#获得图像的大小</span><br><span class="line">width,height = img.size</span><br><span class="line">print(width,height)</span><br><span class="line">#将图片旋转45度</span><br><span class="line">img_rotate = img.rotate(45) </span><br><span class="line">#剪切 crop()四个参数分别是：(左上角点的x坐标，左上角点的y坐标，右下角点的x坐标，右下角点的y坐标)</span><br><span class="line">img1_crop_result = img1.crop((126,0,381,249))</span><br><span class="line">#缩放（Image.ANTIALIAS高质量的缩放）</span><br><span class="line">img2_resize_result = img2.resize((int(width*0.6),int(height*0.6)),Image.ANTIALIAS)</span><br><span class="line">#左右镜像</span><br><span class="line">img3_lr = img3.transpose(Image.FLIP_LEFT_RIGHT)</span><br><span class="line">#上下镜像</span><br><span class="line">img3_bt = img3.transpose(Image.FLIP_TOP_BOTTOM)</span><br><span class="line">#保存图片</span><br><span class="line">img1_crop_result.save(&#x27;/home/aistudio/work/yushuxin_crop_result.jpg&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="Seaborn（带着定制主题和高级界面控制的Matplotlib扩展包，兼容Numpy与Pandas数据结构）"><a href="#Seaborn（带着定制主题和高级界面控制的Matplotlib扩展包，兼容Numpy与Pandas数据结构）" class="headerlink" title="Seaborn（带着定制主题和高级界面控制的Matplotlib扩展包，兼容Numpy与Pandas数据结构）"></a>Seaborn（带着定制主题和高级界面控制的Matplotlib扩展包，兼容Numpy与Pandas数据结构）</h4><p>官方文档：<a target="_blank" rel="noopener" href="http://seaborn.pydata.org/index.html">http://seaborn.pydata.org/index.html</a></p>
<h5 id="1-seaborn基本设置"><a href="#1-seaborn基本设置" class="headerlink" title="1.seaborn基本设置"></a>1.seaborn基本设置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import seaborn as sns</span><br><span class="line"></span><br><span class="line">sns.lineplot(x=[1,2,3],y=[1,2,3])#绘制直线</span><br></pre></td></tr></table></figure>

<p>1）图表大小</p>
<p>sns.set_context(context&#x3D;None, font_scale&#x3D;1, rc&#x3D;None)</p>
<p><strong>context值</strong>：paper，notebook，talk，poster（样式区别不大，可能需要区分图片的应用场合）</p>
<p><strong>font_scale</strong>:字体缩放</p>
<p><strong>rc</strong>：字典格式，设置seaborn其他样式，例如：字体，子大小等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.set_context(&#x27;notebook&#x27;, font_scale=1)</span><br></pre></td></tr></table></figure>

<p>2）设置风格</p>
<p>sns.set_style(style&#x3D;None, rc&#x3D;None)</p>
<p><strong>style</strong>：darkgrid（黑格）, whitegrid（白格）, dark, white, ticks（有线）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#改变风格</span><br><span class="line">sns.set_style(&#x27;darkgrid&#x27;)</span><br><span class="line"># 获取当前风格</span><br><span class="line">sns.axes_style()</span><br></pre></td></tr></table></figure>

<p>3）设置临时风格（只会影响当前图片）</p>
<p>sns.axes_style(style&#x3D;None, rc&#x3D;None)</p>
<p><strong>style</strong>：darkgrid（黑格）, whitegrid（白格）, dark, white, ticks（有线）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.axes_style(&quot;whitegrid&quot;)</span><br></pre></td></tr></table></figure>

<p>4）设置调色板</p>
<p>sns.set_palette(palette, n_colors&#x3D;None, desat&#x3D;None, color_codes&#x3D;False)</p>
<p><strong>palette</strong>:‘deep’（深色）, ‘muted’（柔和色）, ‘pastel’（浅色）, ‘bright’（明亮色）, ‘dark’（暗色）, ‘colorblind’（针对色盲友好的调色板）或者hls（特殊调色板，均匀分布）, husl（改进版hls）</p>
<p><strong>n_colors</strong>：颜色数量</p>
<p><strong>desat</strong>：颜色饱和度（0到1）</p>
<p><strong>color_codes</strong>:当为True时，可使用plt中单字母字符串（例如’r‘表示红色）来表示Seaborn调色板中的颜色，而不仅仅是默认的plt颜色。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.set_palette(&#x27;hls&#x27;, n_colors=3)</span><br></pre></td></tr></table></figure>

<p>5）set方法（上面方法的集合体，啥都能设置）</p>
<p>sns.set(context&#x3D;’notebook’,style&#x3D;’darkgrid’,palette&#x3D;’deep’,font&#x3D;’sans-serif’,font_scale&#x3D;1,color_codes&#x3D;True,rc&#x3D;None,)</p>
<h5 id="2-调色板"><a href="#2-调色板" class="headerlink" title="2.调色板"></a>2.调色板</h5><p>获取颜色：sns.color_palette(palette&#x3D;None, n_colors&#x3D;None, desat&#x3D;None)</p>
<p>显示颜色：sns.palplot(pal, size&#x3D;1)</p>
<p>设置hls饱和度等：sns.hls_palette(n_colors&#x3D;6, h&#x3D;0.01, l&#x3D;0.6, s&#x3D;0.65)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 产生颜色</span><br><span class="line">cls = sns.color_palette(palette=&#x27;hls&#x27;)</span><br><span class="line"># 使用palplot绘制颜色</span><br><span class="line">sns.palplot(cls)</span><br><span class="line"># 设置hls饱和度</span><br><span class="line">cls =sns.hls_palette(n_colors=20, h=0.2, l=0.6, s=0.65)</span><br></pre></td></tr></table></figure>

<p>使用xkcd颜色来命名颜色：sns.xkcd_palette(colors)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.xkcd_palette([&quot;purple&quot;, &quot;violet&quot;, &quot;greyish&quot;, &quot;aqua&quot;, &quot;green&quot;]))</span><br></pre></td></tr></table></figure>

<h5 id="3-内置数据集"><a href="#3-内置数据集" class="headerlink" title="3.内置数据集"></a>3.内置数据集</h5><p>获取数据集名称列表：sns.get_dataset_names()</p>
<p>导入数据集:sns.load_dataset(name, cache&#x3D;True, data_home&#x3D;None, **kws)</p>
<p>cache：控制是否缓存下载的数据集</p>
<p>data_home:指定缓存数据集的本地存储路径</p>
<p>**kws:是一个可变关键字参数（<code>**kwargs</code>），允许用户将额外的关键字参数传递给底层的 Pandas 函数(一般用不到)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdata = sns.load_dataset(&#x27;tips&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="4-常用图表"><a href="#4-常用图表" class="headerlink" title="4.常用图表"></a>4.常用图表</h5><h6 id="4-1分类图表"><a href="#4-1分类图表" class="headerlink" title="4.1分类图表"></a>4.1分类图表</h6><p>1）barplot方法</p>
<p>sns.barplot(x&#x3D;None,y&#x3D;None,hue&#x3D;None,data&#x3D;None,order&#x3D;None,hue_order&#x3D;None,estimator&#x3D;&lt;function meanat 0x000001C71D259288&gt;,ci&#x3D;95,…)</p>
<p>x, y：x轴数据或者 data 中的列名</p>
<p>hue：data 中的列名，用于分类</p>
<p>data：数据</p>
<p>order：绘制类别变量的顺序</p>
<p>hue_order：绘制 hue 变量的顺序</p>
<p>estimator：统计量方法，默认为 <code>mean</code>（均值）</p>
<p>ci：估计值周围的置信区间大小</p>
<p>n_boot：计算置信区间需要迭代的次数</p>
<p>orient：绘图的方向，<code>v</code> 表示垂直，<code>h</code> 表示水平</p>
<p>color：元素的颜色</p>
<p>palette：不同级别 hue 变量的颜色</p>
<p>ax：指定 axes（指定子图？）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 不同时间点，不同性别消费均值：使用barplot中的hue参数</span><br><span class="line">sns.barplot(x=&#x27;time&#x27;, y=&#x27;total_bill&#x27;, data=pdata, hue = &#x27;sex&#x27;)</span><br></pre></td></tr></table></figure>

<p>2）分类散点图</p>
<p>点可以重复：<code>sns.swarmplot(x=None,y=None,hue=None,data=None,...)</code></p>
<p>点不能重复：<code>sns.stripplot(x=None,y=None,hue=None,data=None,...)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 分类散点图</span><br><span class="line">sns.set_palette(sns.color_palette(&#x27;husl&#x27;))</span><br><span class="line">plt.figure(figsize=(16, 4))</span><br><span class="line">ax1 = plt.subplot(1,2,1)#分为一行二列，为第一个图</span><br><span class="line">sns.swarmplot(x=&#x27;sex&#x27;, y=&#x27;total_bill&#x27;,hue=&#x27;time&#x27;, data=pdata, ax=ax1, dodge=True)</span><br><span class="line">ax2 = plt.subplot(1,2,2)#分为一行二列，为第二个图</span><br><span class="line">sns.stripplot(x=&#x27;sex&#x27;, y=&#x27;total_bill&#x27;,hue=&#x27;time&#x27;, data=pdata, ax=ax2,dodge=True)#dodge同一水平位置是否散开</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3）数量统计</p>
<p>数量统计：<code>sns.countplot(x=None,y=None,hue=None,data=None,...)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.countplot(x=&#x27;sex&#x27;, hue=&#x27;time&#x27;, data=pdata)</span><br></pre></td></tr></table></figure>

<h6 id="4-2分布图"><a href="#4-2分布图" class="headerlink" title="4.2分布图"></a>4.2分布图</h6><p>1）直方图</p>
<p>sns.distplot(a,bins&#x3D;None,hist&#x3D;True,kde&#x3D;True, rug&#x3D;False,fit&#x3D;None,…)(该方法已被弃用)</p>
<p>sns.histplot(data,x&#x3D;None,y&#x3D;None,hue&#x3D;None,kde&#x3D;None,…)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用直方图查看用户消费额度分布</span><br><span class="line">sns.histplot(pdata[&#x27;total_bill&#x27;], color=&#x27;g&#x27;, kde=True)</span><br><span class="line"># 设置不同颜色</span><br><span class="line">sns.distplot(pdata[&#x27;total_bill&#x27;],color=&#x27;g&#x27;,rug=True, rug_kws=&#123;&#x27;color&#x27;:&#x27;r&#x27;&#125;, kde_kws=&#123;&#x27;color&#x27;:&#x27;b&#x27;&#125;)</span><br><span class="line">#rug：通常在 X 轴上绘制小线条（或短条），每条线对应数据集中一个数据点，可以快速识别数据集中数据的密集区域和稀疏区域。</span><br><span class="line"># 设置bins，横坐标箱数的改变，即柱子个数</span><br><span class="line">sns.histplot(pdata[&#x27;total_bill&#x27;],bins=10, color=&#x27;g&#x27;, kde=True)</span><br></pre></td></tr></table></figure>

<p>2）KDE图</p>
<p>拟合并绘制单变量或双变量核密度估计图</p>
<p><code>sns.kdeplot(data,data2=None,shade=False,vertical=False,kernel=&#39;gau&#39;,...)</code></p>
<p>data，data2：一维数据</p>
<p>shade：是否显示阴影</p>
<p>vertical：方向，<code>True</code> 表示垂直，<code>False</code> 表示水平</p>
<p>kernel：核函数决定了如何将数据点的贡献聚合到密度估计中，可选值包括 ‘gau’, ‘cos’, ‘biw’, ‘epa’, ‘tri’, ‘triw’（基本不用）</p>
<p>bw：KDE 的带宽（bandwidth）控制 KDE 的平滑程度，可选值包括 ‘scott’, ‘silverman’, scalar, pair of scalars（基本不用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(pdata.total_bill, color=&#x27;r&#x27;)</span><br><span class="line"># 双变量核密度：消费与小费</span><br><span class="line">sns.kdeplot(data=pdata, x=&quot;total_bill&quot;, y=&quot;tip&quot;, cmap=&#x27;Accent&#x27;)#cmap颜色渐进变化</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="4-3关系图"><a href="#4-3关系图" class="headerlink" title="4.3关系图"></a>4.3关系图</h6><p>1）散点图</p>
<p>sns.scatterplot(x&#x3D;None,y&#x3D;None,hue&#x3D;None,style&#x3D;None,size&#x3D;None,data&#x3D;None,palette&#x3D;None)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#花萼长宽</span><br><span class="line">sns.scatterplot(x=&#x27;sepal_length&#x27;, y = &#x27;sepal_width&#x27;, hue=&#x27;species&#x27;, data=iris)</span><br><span class="line">#花瓣长宽</span><br><span class="line">sns.scatterplot(x=&#x27;petal_length&#x27;, y = &#x27;petal_width&#x27;, hue=&#x27;species&#x27;, data=iris)</span><br></pre></td></tr></table></figure>

<p>2）线性回归图</p>
<p>lmplot：sns.lmplot(x,y,data,hue&#x3D;None,col&#x3D;None,row&#x3D;None,…)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import statsmodels</span><br><span class="line">sns.lmplot(x=&#x27;petal_length&#x27;, y = &#x27;petal_width&#x27;, hue=&#x27;species&#x27;, data=iris,truncate=False)</span><br><span class="line">#truncate表示在点附近以外的线是否截断</span><br></pre></td></tr></table></figure>

<h6 id="4-4其他图表"><a href="#4-4其他图表" class="headerlink" title="4.4其他图表"></a>4.4其他图表</h6><p>1）catplot（多图展示）</p>
<p>将分类图绘制到 FacetGrid 上图级别接口</p>
<p>在不同的图表中对数据进行展示,支持多种展示方式</p>
<p><code>seaborn.catplot(x=None, y=None, hue=None, data=None, row=None, col=None, col_wrap=None,...)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=&quot;sex&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;, data=sns.load_dataset(&quot;tips&quot;), kind=&quot;box&quot;)</span><br><span class="line">#定col（横着）:</span><br><span class="line">sns.catplot(x=&quot;sex&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;,data=sns.load_dataset(&quot;tips&quot;), kind=&quot;box&quot;, col = &#x27;time&#x27;)</span><br><span class="line">#定row（竖着）:</span><br><span class="line">sns.catplot(x=&quot;sex&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;,data=sns.load_dataset(&quot;tips&quot;), kind=&quot;box&quot;, row = &#x27;time&#x27;)</span><br><span class="line">#指定row与col</span><br><span class="line">sns.catplot(x=&quot;sex&quot;, y=&quot;total_bill&quot;, data=sns.load_dataset(&quot;tips&quot;), kind=&quot;box&quot;, row = &#x27;time&#x27;, col=&#x27;day&#x27;)</span><br></pre></td></tr></table></figure>

<p>2）relplot</p>
<p>类似catplot</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.relplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=sns.load_dataset(&quot;tips&quot;), kind=&quot;line&quot;,col=&#x27;day&#x27;)</span><br></pre></td></tr></table></figure>

<p>3）FacetGrid</p>
<p>根据设置条件生成多个图表，效果与catplot，relplot类似</p>
<p><code>g = sns.FacetGrid(data, row=None, col=None, hue=None, col_wrap=None,...)</code></p>
<p><code>g.map(func, *args, **kwargs)</code>：绘制图表制图表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tips=sns.load_dataset(&quot;tips&quot;)</span><br><span class="line">g = sns.FacetGrid(tips, row=&#x27;sex&#x27;, col=&#x27;day&#x27;)</span><br><span class="line">g.map(plt.hist, &#x27;total_bill&#x27;)</span><br></pre></td></tr></table></figure>

<p>4）PairGrid</p>
<p>数据集中成对关系的子图<br>将数据集中每个变量映射到多个子图中，两两交叉<br>g&#x3D;sns.PairGrid(data,hue&#x3D;None,hue_order&#x3D;None,palette&#x3D;None,hue_kws&#x3D;None,vars&#x3D;None,…)<br>g.map_diag(func, ** kwargs)：绘制对角线图表<br>g.map_offdiag(func, **kwargs)：绘制非对角线图表线图表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">g = sns.PairGrid(iris)</span><br><span class="line">g = g.map(plt.scatter)</span><br><span class="line"></span><br><span class="line">#设置对角线与其他方式</span><br><span class="line">g = sns.PairGrid(iris, hue=&quot;species&quot;)</span><br><span class="line">g = g.map_diag(plt.hist)</span><br><span class="line">g = g.map_offdiag(plt.scatter)</span><br><span class="line">g = g.add_legend()</span><br></pre></td></tr></table></figure>

<p>5）JointGrid</p>
<p>绘制双变量与边际单变量图表</p>
<p>g &#x3D; sns.JointGrid(x, y, data&#x3D;None, height&#x3D;6, ratio&#x3D;5, space&#x3D;0.2, dropna&#x3D;True, xlim&#x3D;None, ylim&#x3D;None,size&#x3D;None)</p>
<p>g.plot(joint_func, marginal_func, annot_func&#x3D;None) #绘制联合图表与边缘图表</p>
<p>g.plot_joint(func, ** kwargs) #绘制联合图表</p>
<p>g.plot_marginals(func, **kwargs) #绘制边缘图表绘制边缘图表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = sns.JointGrid(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips)</span><br><span class="line">#绘制回归图与直方图</span><br><span class="line">g.plot(sns.regplot, sns.histplot)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6）joinplot</p>
<p>绘制变量的双变量及单变量图</p>
<p>g &#x3D; sns.jointplot(x, y,data&#x3D;None,kind&#x3D;’scatter’,stat_func&#x3D;None,color&#x3D;None,…)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tips = sns.load_dataset(&quot;tips&quot;)</span><br><span class="line">g = sns.jointplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips)</span><br><span class="line">g = sns.jointplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips, kind=&quot;reg&quot;)#kind改变图的类型</span><br><span class="line">sns.jointplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips, kind=&quot;hex&quot;)</span><br><span class="line"></span><br><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">g = sns.jointplot(x=&quot;sepal_width&quot;, y=&quot;petal_length&quot;, data=iris,kind=&quot;kde&quot;, space=0, color=&quot;g&quot;)</span><br><span class="line"></span><br><span class="line">g = sns.jointplot(x=&quot;sepal_length&quot;, y=&quot;sepal_width&quot;, data=iris, color=&quot;k&quot;)</span><br><span class="line">g.plot_joint(sns.kdeplot, zorder=0, n_levels=6)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Scipy（提供了更多的高级科学计算功能，包括优化、信号处理、统计分析、插值、线性代数）"><a href="#Scipy（提供了更多的高级科学计算功能，包括优化、信号处理、统计分析、插值、线性代数）" class="headerlink" title="Scipy（提供了更多的高级科学计算功能，包括优化、信号处理、统计分析、插值、线性代数）"></a>Scipy（提供了更多的高级科学计算功能，包括优化、信号处理、统计分析、插值、线性代数）</h4><h5 id="1-数学优化"><a href="#1-数学优化" class="headerlink" title="1.数学优化"></a>1.数学优化</h5><h6 id="1-1minimize-function-x-method-xxx"><a href="#1-1minimize-function-x-method-xxx" class="headerlink" title="1.1minimize(function, x, method&#x3D;xxx)"></a>1.1minimize(function, x, method&#x3D;xxx)</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from scipy.optimize import minimize</span><br><span class="line"></span><br><span class="line"># 定义目标函数</span><br><span class="line">def objective(x):</span><br><span class="line">    return x[0]**2 + x[1]**2</span><br><span class="line"></span><br><span class="line"># 初始猜测点</span><br><span class="line">x0 = [1, 1]</span><br><span class="line"></span><br><span class="line"># 使用BFGS算法寻找最小值</span><br><span class="line">result = minimize(objective, x0, method=&#x27;BFGS&#x27;)</span><br><span class="line"></span><br><span class="line"># 输出最小值和最优参数</span><br><span class="line">print(&quot;最小值:&quot;, result.fun)#函数最小值</span><br><span class="line">print(&quot;最优参数:&quot;, result.x)#函数最小时的参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="1-2约束优化"><a href="#1-2约束优化" class="headerlink" title="1.2约束优化"></a>1.2约束优化</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from scipy.optimize import minimize</span><br><span class="line"></span><br><span class="line"># 定义目标函数</span><br><span class="line">def objective(x):</span><br><span class="line">    return x[0]**2 + x[1]**2</span><br><span class="line"></span><br><span class="line"># 定义约束条件</span><br><span class="line">constraint = (&#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: lambda x: x[0] - 2&#125;,#x0大于等于2</span><br><span class="line">              &#123;&#x27;type&#x27;: &#x27;ineq&#x27;, &#x27;fun&#x27;: lambda x: x[1] - 2&#125;)#x1大于等于2</span><br><span class="line"></span><br><span class="line"># 初始猜测点</span><br><span class="line">x0 = [1, 1]</span><br><span class="line"></span><br><span class="line"># 使用SLSQP算法进行约束优化</span><br><span class="line">result = minimize(objective, x0, method=&#x27;SLSQP&#x27;, constraints=constraint)</span><br><span class="line"></span><br><span class="line"># 输出最小值和最优参数</span><br><span class="line">print(&quot;最小值:&quot;, result.fun)</span><br><span class="line">print(&quot;最优参数:&quot;, result.x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-统计分析"><a href="#2-统计分析" class="headerlink" title="2.统计分析"></a>2.统计分析</h5><h6 id="2-1统计描述"><a href="#2-1统计描述" class="headerlink" title="2.1统计描述"></a>2.1统计描述</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from scipy import stats</span><br><span class="line"></span><br><span class="line"># 生成随机数据</span><br><span class="line">data = np.random.normal(0, 1, 100)</span><br><span class="line"></span><br><span class="line"># 计算均值和标准差</span><br><span class="line">mean = np.mean(data)</span><br><span class="line">std_dev = np.std(data)</span><br><span class="line"></span><br><span class="line"># 计算数据的正态分布拟合参数</span><br><span class="line">params = stats.norm.fit(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-2假设检验"><a href="#2-2假设检验" class="headerlink" title="2.2假设检验"></a>2.2假设检验</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from scipy import stats</span><br><span class="line"></span><br><span class="line"># 生成两组随机数据</span><br><span class="line">data1 = np.random.normal(0, 1, 100)</span><br><span class="line">data2 = np.random.normal(1, 1, 100)</span><br><span class="line"></span><br><span class="line"># 执行独立样本t检验</span><br><span class="line">t_statistic, p_value = stats.ttest_ind(data1, data2)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line">t统计量和p值</span><br><span class="line">print(&quot;t统计量:&quot;, t_statistic)</span><br><span class="line">print(&quot;p值:&quot;, p_value)</span><br></pre></td></tr></table></figure>

<h6 id="2-3统计分布"><a href="#2-3统计分布" class="headerlink" title="2.3统计分布"></a>2.3统计分布</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from scipy import stats</span><br><span class="line"></span><br><span class="line"># 创建一个正态分布随机变量</span><br><span class="line">rv = stats.norm(loc=0, scale=1)</span><br><span class="line"></span><br><span class="line"># 计算概率密度函数的值</span><br><span class="line">pdf_value = rv.pdf(0)</span><br><span class="line"></span><br><span class="line"># 计算累积分布函数的值</span><br><span class="line">cdf_value = rv.cdf(0.5)</span><br></pre></td></tr></table></figure>

<h5 id="4-信号处理（应该不太用的上）"><a href="#4-信号处理（应该不太用的上）" class="headerlink" title="4.信号处理（应该不太用的上）"></a>4.信号处理（应该不太用的上）</h5><h6 id="4-1滤波"><a href="#4-1滤波" class="headerlink" title="4.1滤波"></a>4.1滤波</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from scipy import signal</span><br><span class="line"></span><br><span class="line"># 生成一个包含噪声的信号</span><br><span class="line">t = np.linspace(0, 10, 1000)</span><br><span class="line">signal_data = np.sin(t) + np.random.normal(0, 0.5, 1000)</span><br><span class="line"></span><br><span class="line"># 设计一个低通滤波器</span><br><span class="line">b, a = signal.butter(4, 0.1, &#x27;low&#x27;)</span><br><span class="line"></span><br><span class="line"># 应用滤波器</span><br><span class="line">filtered_signal = signal.filtfilt(b, a, signal_data)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="4-2快速傅里叶变化"><a href="#4-2快速傅里叶变化" class="headerlink" title="4.2快速傅里叶变化"></a>4.2快速傅里叶变化</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from scipy import fft</span><br><span class="line"></span><br><span class="line"># 生成一个包含两个频率分量的信号</span><br><span class="line">t = np.linspace(0, 1, 1000)</span><br><span class="line">signal_data = np.sin(2 * np.pi * 5 * t) + np.sin(2 * np.pi * 10 * t)</span><br><span class="line"></span><br><span class="line"># 进行快速傅里叶变换</span><br><span class="line">fft_result = fft.fft(signal_data)</span><br><span class="line"></span><br><span class="line"># 计算频率谱</span><br><span class="line">freq = fft.fftfreq(len(fft_result))</span><br><span class="line"></span><br><span class="line"># 提取幅度谱</span><br><span class="line">amplitude_spectrum = np.abs(fft_result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5-插值"><a href="#5-插值" class="headerlink" title="5.插值"></a>5.插值</h5><p>用于估计在给定数据点之间的值</p>
<h6 id="5-1线性插值"><a href="#5-1线性插值" class="headerlink" title="5.1线性插值"></a>5.1线性插值</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from scipy import interpolate</span><br><span class="line"></span><br><span class="line"># 创建一些示例数据点</span><br><span class="line">x = np.array([0, 1, 2, 3, 4])</span><br><span class="line">y = np.array([0, 2, 1, 3, 4])</span><br><span class="line"></span><br><span class="line"># 创建线性插值函数</span><br><span class="line">linear_interp = interpolate.interp1d(x, y)</span><br><span class="line"></span><br><span class="line"># 在新的点上进行插值</span><br><span class="line">new_x = np.array([0.5, 1.5, 2.5])</span><br><span class="line">interpolated_values = linear_interp(new_x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="5-2二维插值"><a href="#5-2二维插值" class="headerlink" title="5.2二维插值"></a>5.2二维插值</h6><p>interp2d（老方法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from scipy import interpolate</span><br><span class="line"></span><br><span class="line"># 创建一些示例数据点</span><br><span class="line">x = np.array([0, 1, 2, 3, 4])</span><br><span class="line">y = np.array([0, 2, 1, 3, 4])</span><br><span class="line">z = np.array([[0, 1, 2, 3, 4],</span><br><span class="line">              [4, 3, 2, 1, 0]])</span><br><span class="line"></span><br><span class="line"># 创建二维插值函数</span><br><span class="line">interp2d = interpolate.interp2d(x, y, z, kind=&#x27;linear&#x27;)</span><br><span class="line"></span><br><span class="line"># 在新的点上进行插值</span><br><span class="line">new_x = np.array([0.5, 1.5, 2.5])</span><br><span class="line">new_y = np.array([0.5, 1.5])</span><br><span class="line">interpolated_values = interp2d(new_x, new_y)</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>RegularGridInterpolator（新方法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from scipy.interpolate import RegularGridInterpolator</span><br><span class="line"></span><br><span class="line"># 定义数据点</span><br><span class="line">x = np.array([0, 1, 2, 3, 4])</span><br><span class="line">y = np.array([0, 1, 2, 3, 4])</span><br><span class="line">z = np.array([[0, 1, 2, 3, 4],</span><br><span class="line">              [4, 3, 2, 1, 0],</span><br><span class="line">              [1, 2, 3, 4, 5],</span><br><span class="line">              [2, 1, 0, 4, 3],</span><br><span class="line">              [5, 4, 3, 2, 1]])</span><br><span class="line"></span><br><span class="line"># 创建插值函数</span><br><span class="line">interp_func = RegularGridInterpolator((x, y), z)</span><br><span class="line"></span><br><span class="line"># 在新点进行插值</span><br><span class="line">new_points = np.array([[0.5, 0.5], [1.5, 1.5], [2.5, 2.5]])</span><br><span class="line">interpolated_values = interp_func(new_points)</span><br><span class="line"></span><br><span class="line">print(interpolated_values)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="6-常用函数"><a href="#6-常用函数" class="headerlink" title="6.常用函数"></a>6.常用函数</h5><p><strong>scipy.integrate： 这个模块提供了数值积分和常微分方程求解器。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from scipy.integrate import quad</span><br><span class="line"></span><br><span class="line"># 定义一个函数</span><br><span class="line">def integrand(x):</span><br><span class="line">    return x**2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 计算从0到1的积分</span><br><span class="line">result, error = quad(integrand, 0, 1)</span><br><span class="line">print(&quot;积分结果:&quot;, result,&quot;误差:&quot;, error)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>scipy.linalg ：涵盖了线性代数的基础和高级功能</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from scipy import linalg</span><br><span class="line"></span><br><span class="line"># 创建一个矩阵</span><br><span class="line">A = np.array([[1, 2], [3, 4]])</span><br><span class="line"></span><br><span class="line"># 计算矩阵的逆</span><br><span class="line">inv_A = linalg.inv(A)</span><br><span class="line"></span><br><span class="line"># 创建一个向量</span><br><span class="line">b = np.array([5, 6])</span><br><span class="line"></span><br><span class="line"># 计算A的逆乘以向量b</span><br><span class="line">x = np.dot(inv_A, b)</span><br><span class="line"></span><br><span class="line">print(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>scipy.optimize</strong> ：提供了函数最小化、曲线拟合和求根的算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from scipy import optimize</span><br><span class="line"></span><br><span class="line">def objective_function(x):</span><br><span class="line">    return x**2</span><br><span class="line"></span><br><span class="line">result = optimize.minimize(objective_function, x0=1, method=&quot;BFGS&quot;)</span><br><span class="line">print(result.x)  # 输出最小值点</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>scipy.sparse</strong> ：包含了稀疏矩阵的数据结构以及相关的快速运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from scipy import sparse</span><br><span class="line"></span><br><span class="line"># 创建一个稀疏矩阵</span><br><span class="line">A = sparse.csr_matrix(([1, 2, 3], [0, 1, 2], [1, 0, 0]), shape=(3, 3))</span><br><span class="line"></span><br><span class="line"># 计算矩阵的逆</span><br><span class="line">inv_A = A.inv()</span><br><span class="line"></span><br><span class="line"># 打印稀疏矩阵的逆</span><br><span class="line">print(inv_A.toarray())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>scipy.interpolate</strong> ：为数据点提供多种插值工具和算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">from scipy import interpolate</span><br><span class="line"></span><br><span class="line">x = [1, 2, 3, 4, 5]</span><br><span class="line">y = [2, 3, 5, 7, 11]</span><br><span class="line"></span><br><span class="line"># 创建一个插值函数</span><br><span class="line">f = interpolate.interp1d(x, y, kind=&quot;linear&quot;)</span><br><span class="line"></span><br><span class="line"># 计算插值函数在特定点的值</span><br><span class="line">print(f(3.5))</span><br><span class="line"></span><br><span class="line"># 创建一个插值函数，并绘制原始数据和插值曲线</span><br><span class="line">xnew = np.linspace(1, 5, 100)</span><br><span class="line">ynew = f(xnew)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y, &quot;o&quot;, xnew, ynew, &quot;-&quot;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>scipy.fftpack</strong> ：提供了快速傅里叶变换的工具。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from scipy import fftpack</span><br><span class="line"></span><br><span class="line"># 创建一个信号</span><br><span class="line">signal = [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line"># 计算信号的傅里叶变换</span><br><span class="line">fourier_transform = fftpack.fft(signal)</span><br><span class="line"></span><br><span class="line"># 打印傅里叶变换的结果</span><br><span class="line">print(fourier_transform)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>scipy.stats</strong> ：包含大量的概率分布和统计函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from scipy import stats</span><br><span class="line"></span><br><span class="line"># 创建一个正态分布的随机变量</span><br><span class="line">random_variable = stats.norm.rvs(size=100)</span><br><span class="line"></span><br><span class="line"># 计算随机变量的均值和标准差</span><br><span class="line">mean = random_variable.mean()</span><br><span class="line">std_dev = random_variable.std()</span><br><span class="line"></span><br><span class="line">print(&quot;Mean:&quot;, mean)</span><br><span class="line">print(&quot;Standard Deviation:&quot;, std_dev)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Zhen Xie</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2024/10/18/Week1%20python%E5%AD%A6%E4%B9%A0/">http://example.com/2024/10/18/Week1%20python%E5%AD%A6%E4%B9%A0/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"># 机器学习</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2024/07/18/%E6%96%87%E7%8C%AE3/">文献3</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Zhen Xie | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>